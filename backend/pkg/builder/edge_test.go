package builder

import (
	"testing"

	"github.com/smilemakc/mbflow/pkg/models"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// ==================== NewEdge Tests ====================

func TestNewEdge_Success(t *testing.T) {
	edge, err := NewEdge("node1", "node2").Build()

	require.NoError(t, err)
	assert.Equal(t, "edge_node1_node2", edge.ID)
	assert.Equal(t, "node1", edge.From)
	assert.Equal(t, "node2", edge.To)
	assert.Empty(t, edge.Condition)
	assert.NotNil(t, edge.Metadata)
}

func TestNewEdge_AutoGeneratedID(t *testing.T) {
	tests := []struct {
		name       string
		from       string
		to         string
		expectedID string
	}{
		{"simple nodes", "n1", "n2", "edge_n1_n2"},
		{"long names", "http_fetch_data", "transform_result", "edge_http_fetch_data_transform_result"},
		{"with dashes", "node-1", "node-2", "edge_node-1_node-2"},
		{"with underscores", "node_1", "node_2", "edge_node_1_node_2"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			edge, err := NewEdge(tt.from, tt.to).Build()

			require.NoError(t, err)
			assert.Equal(t, tt.expectedID, edge.ID)
			assert.Equal(t, tt.from, edge.From)
			assert.Equal(t, tt.to, edge.To)
		})
	}
}

// ==================== WithEdgeID Tests ====================

func TestWithEdgeID_CustomID(t *testing.T) {
	edge, err := NewEdge("node1", "node2",
		WithEdgeID("custom_edge_id"),
	).Build()

	require.NoError(t, err)
	assert.Equal(t, "custom_edge_id", edge.ID)
	assert.Equal(t, "node1", edge.From)
	assert.Equal(t, "node2", edge.To)
}

func TestWithEdgeID_EmptyID(t *testing.T) {
	edge, err := NewEdge("node1", "node2",
		WithEdgeID(""),
	).Build()

	assert.Error(t, err)
	assert.Nil(t, edge)
	assert.Contains(t, err.Error(), "edge ID cannot be empty")
}

// ==================== WithCondition Tests ====================

func TestWithCondition_Success(t *testing.T) {
	tests := []struct {
		name      string
		condition string
	}{
		{"simple boolean", "input.success"},
		{"comparison", "input.value > 10"},
		{"equality", "input.status == 'completed'"},
		{"complex expression", "input.score >= 80 && input.grade != 'F'"},
		{"nested fields", "input.data.user.active"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			edge, err := NewEdge("node1", "node2",
				WithCondition(tt.condition),
			).Build()

			require.NoError(t, err)
			assert.Equal(t, tt.condition, edge.Condition)
		})
	}
}

func TestWithCondition_EmptyCondition(t *testing.T) {
	// Empty condition is allowed (means unconditional edge)
	edge, err := NewEdge("node1", "node2",
		WithCondition(""),
	).Build()

	require.NoError(t, err)
	assert.Empty(t, edge.Condition)
}

// ==================== WhenTrue Tests ====================

func TestWhenTrue_Success(t *testing.T) {
	tests := []struct {
		name      string
		condition string
		expected  string
	}{
		{"simple field", "input.success", "input.success"},
		{"comparison", "input.value > 10", "input.value > 10"},
		{"complex", "input.a && input.b", "input.a && input.b"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			edge, err := NewEdge("node1", "node2",
				WhenTrue(tt.condition),
			).Build()

			require.NoError(t, err)
			assert.Equal(t, tt.expected, edge.Condition)
		})
	}
}

func TestWhenTrue_EmptyCondition(t *testing.T) {
	edge, err := NewEdge("node1", "node2",
		WhenTrue(""),
	).Build()

	assert.Error(t, err)
	assert.Nil(t, edge)
	assert.Contains(t, err.Error(), "condition cannot be empty")
}

// ==================== WhenFalse Tests ====================

func TestWhenFalse_Success(t *testing.T) {
	tests := []struct {
		name      string
		condition string
		expected  string
	}{
		{"simple field", "input.success", "!(input.success)"},
		{"comparison", "input.value > 10", "!(input.value > 10)"},
		{"equality", "input.status == 'active'", "!(input.status == 'active')"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			edge, err := NewEdge("node1", "node2",
				WhenFalse(tt.condition),
			).Build()

			require.NoError(t, err)
			assert.Equal(t, tt.expected, edge.Condition)
		})
	}
}

func TestWhenFalse_EmptyCondition(t *testing.T) {
	edge, err := NewEdge("node1", "node2",
		WhenFalse(""),
	).Build()

	assert.Error(t, err)
	assert.Nil(t, edge)
	assert.Contains(t, err.Error(), "condition cannot be empty")
}

// ==================== WhenEqual Tests ====================

func TestWhenEqual_Success(t *testing.T) {
	tests := []struct {
		name     string
		field    string
		value    string
		expected string
	}{
		{"status success", "output.status", "success", `output.status == "success"`},
		{"count zero", "output.count", "0", `output.count == "0"`},
		{"nested field", "output.data.user.role", "admin", `output.data.user.role == "admin"`},
		{"boolean string", "output.active", "true", `output.active == "true"`},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			edge, err := NewEdge("node1", "node2",
				WhenEqual(tt.field, tt.value),
			).Build()

			require.NoError(t, err)
			assert.Equal(t, tt.expected, edge.Condition)
		})
	}
}

func TestWhenEqual_EmptyField(t *testing.T) {
	edge, err := NewEdge("node1", "node2",
		WhenEqual("", "value"),
	).Build()

	assert.Error(t, err)
	assert.Nil(t, edge)
	assert.Contains(t, err.Error(), "field cannot be empty")
}

func TestWhenEqual_EmptyValue(t *testing.T) {
	edge, err := NewEdge("node1", "node2",
		WhenEqual("output.status", ""),
	).Build()

	assert.Error(t, err)
	assert.Nil(t, edge)
	assert.Contains(t, err.Error(), "value cannot be empty")
}

func TestWhenEqual_BothEmpty(t *testing.T) {
	edge, err := NewEdge("node1", "node2",
		WhenEqual("", ""),
	).Build()

	assert.Error(t, err)
	assert.Nil(t, edge)
	// Should fail on field validation first
	assert.Contains(t, err.Error(), "field cannot be empty")
}

// ==================== WithEdgeMetadata Tests ====================

func TestWithEdgeMetadata_Success(t *testing.T) {
	edge, err := NewEdge("node1", "node2",
		WithEdgeMetadata("priority", "high"),
		WithEdgeMetadata("label", "success path"),
		WithEdgeMetadata("weight", 10),
	).Build()

	require.NoError(t, err)
	assert.Equal(t, "high", edge.Metadata["priority"])
	assert.Equal(t, "success path", edge.Metadata["label"])
	assert.Equal(t, 10, edge.Metadata["weight"])
}

func TestWithEdgeMetadata_EmptyKey(t *testing.T) {
	edge, err := NewEdge("node1", "node2",
		WithEdgeMetadata("", "value"),
	).Build()

	assert.Error(t, err)
	assert.Nil(t, edge)
	assert.Contains(t, err.Error(), "metadata key cannot be empty")
}

func TestWithEdgeMetadata_OverwriteValue(t *testing.T) {
	edge, err := NewEdge("node1", "node2",
		WithEdgeMetadata("key", "value1"),
		WithEdgeMetadata("key", "value2"),
	).Build()

	require.NoError(t, err)
	// Second value should overwrite the first
	assert.Equal(t, "value2", edge.Metadata["key"])
}

func TestWithEdgeMetadata_VariousTypes(t *testing.T) {
	edge, err := NewEdge("node1", "node2",
		WithEdgeMetadata("string", "text"),
		WithEdgeMetadata("int", 42),
		WithEdgeMetadata("float", 3.14),
		WithEdgeMetadata("bool", true),
		WithEdgeMetadata("map", map[string]any{"nested": "value"}),
		WithEdgeMetadata("slice", []string{"a", "b", "c"}),
	).Build()

	require.NoError(t, err)
	assert.Equal(t, "text", edge.Metadata["string"])
	assert.Equal(t, 42, edge.Metadata["int"])
	assert.Equal(t, 3.14, edge.Metadata["float"])
	assert.Equal(t, true, edge.Metadata["bool"])
	assert.NotNil(t, edge.Metadata["map"])
	assert.NotNil(t, edge.Metadata["slice"])
}

// ==================== Complex Integration Tests ====================

func TestEdgeBuilder_ConditionalEdgeWithMetadata(t *testing.T) {
	edge, err := NewEdge("conditional_node", "success_node",
		WithEdgeID("success_branch"),
		WhenTrue("output.success"),
		WithEdgeMetadata("branch", "success"),
		WithEdgeMetadata("color", "green"),
	).Build()

	require.NoError(t, err)
	assert.Equal(t, "success_branch", edge.ID)
	assert.Equal(t, "conditional_node", edge.From)
	assert.Equal(t, "success_node", edge.To)
	assert.Equal(t, "output.success", edge.Condition)
	assert.Equal(t, "success", edge.Metadata["branch"])
	assert.Equal(t, "green", edge.Metadata["color"])
}

func TestEdgeBuilder_MultipleConditionalBranches(t *testing.T) {
	// Success branch
	successEdge, err := NewEdge("check", "success",
		WhenEqual("output.status", "success"),
		WithEdgeMetadata("branch", "success"),
	).Build()
	require.NoError(t, err)
	assert.Equal(t, `output.status == "success"`, successEdge.Condition)

	// Failure branch
	failureEdge, err := NewEdge("check", "failure",
		WhenEqual("output.status", "failure"),
		WithEdgeMetadata("branch", "failure"),
	).Build()
	require.NoError(t, err)
	assert.Equal(t, `output.status == "failure"`, failureEdge.Condition)

	// Both edges should have different IDs
	assert.NotEqual(t, successEdge.ID, failureEdge.ID)
	assert.Equal(t, "edge_check_success", successEdge.ID)
	assert.Equal(t, "edge_check_failure", failureEdge.ID)
}

func TestEdgeBuilder_ComplexConditionWithMetadata(t *testing.T) {
	edge, err := NewEdge("validator", "processor",
		WithCondition("output.score >= 80 && output.grade != 'F' && output.attempts < 3"),
		WithEdgeMetadata("description", "Valid for processing"),
		WithEdgeMetadata("priority", 1),
	).Build()

	require.NoError(t, err)
	assert.Contains(t, edge.Condition, "output.score >= 80")
	assert.Contains(t, edge.Condition, "output.grade != 'F'")
	assert.Contains(t, edge.Condition, "output.attempts < 3")
	assert.Equal(t, "Valid for processing", edge.Metadata["description"])
	assert.Equal(t, 1, edge.Metadata["priority"])
}

func TestEdgeBuilder_UnconditionalEdge(t *testing.T) {
	edge, err := NewEdge("node1", "node2").Build()

	require.NoError(t, err)
	assert.Empty(t, edge.Condition)
	assert.Equal(t, "node1", edge.From)
	assert.Equal(t, "node2", edge.To)
}

func TestEdgeBuilder_ChainOfEdges(t *testing.T) {
	// Create a chain: node1 -> node2 -> node3 -> node4
	edges := []struct {
		from string
		to   string
	}{
		{"node1", "node2"},
		{"node2", "node3"},
		{"node3", "node4"},
	}

	builtEdges := make([]*models.Edge, 0, len(edges))
	for _, e := range edges {
		edge, err := NewEdge(e.from, e.to).Build()
		require.NoError(t, err)
		builtEdges = append(builtEdges, edge)
	}

	assert.Len(t, builtEdges, 3)
	assert.Equal(t, "edge_node1_node2", builtEdges[0].ID)
	assert.Equal(t, "edge_node2_node3", builtEdges[1].ID)
	assert.Equal(t, "edge_node3_node4", builtEdges[2].ID)
}

func TestEdgeBuilder_ParallelBranches(t *testing.T) {
	// Create parallel branches from one node to multiple nodes
	root := "root"
	branches := []string{"branch1", "branch2", "branch3"}

	edges := make([]*models.Edge, 0, len(branches))
	for _, branch := range branches {
		edge, err := NewEdge(root, branch,
			WithEdgeMetadata("branch_name", branch),
		).Build()
		require.NoError(t, err)
		edges = append(edges, edge)
	}

	assert.Len(t, edges, 3)
	for i, edge := range edges {
		assert.Equal(t, root, edge.From)
		assert.Equal(t, branches[i], edge.To)
		assert.Equal(t, branches[i], edge.Metadata["branch_name"])
	}
}

func TestEdgeBuilder_ErrorPropagation(t *testing.T) {
	// Test that error from first option prevents further processing
	edge, err := NewEdge("node1", "node2",
		WithEdgeID(""),                       // This will fail
		WithEdgeMetadata("should", "ignore"), // This should not be processed
	).Build()

	assert.Error(t, err)
	assert.Nil(t, edge)
	assert.Contains(t, err.Error(), "edge ID cannot be empty")
}
