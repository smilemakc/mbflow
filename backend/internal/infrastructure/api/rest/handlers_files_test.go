package rest

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"mime/multipart"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/smilemakc/mbflow/internal/application/filestorage"
	"github.com/smilemakc/mbflow/internal/config"
	"github.com/smilemakc/mbflow/internal/infrastructure/logger"
	"github.com/smilemakc/mbflow/internal/infrastructure/storage"
	"github.com/smilemakc/mbflow/testutil"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// setupFileHandlersTest sets up a test environment for file handlers
func setupFileHandlersTest(t *testing.T) (*FileHandlers, *gin.Engine, *storage.FileRepository, filestorage.Manager, func()) {
	db, dbCleanup := testutil.SetupTestTx(t)

	fileRepo := storage.NewFileRepository(db)

	log := logger.New(config.LoggingConfig{
		Level:  "error",
		Format: "text",
	})

	// Create storage manager with local filesystem
	cfg := &filestorage.ManagerConfig{
		BasePath: t.TempDir(), // Use temporary directory for tests
	}
	storageManager := filestorage.NewStorageManager(cfg, log)

	handlers := NewFileHandlers(fileRepo, storageManager, log)

	gin.SetMode(gin.TestMode)
	router := gin.New()
	api := router.Group("/api/v1")
	{
		api.POST("/files", handlers.HandleUploadFile)
		api.GET("/files/:id", handlers.HandleGetFile)
		api.GET("/files/:id/metadata", handlers.HandleGetFileMetadata)
		api.DELETE("/files/:id", handlers.HandleDeleteFile)
		api.GET("/files", handlers.HandleListFiles)
		api.GET("/files/usage", handlers.HandleGetStorageUsage)
	}

	cleanup := func() {
		storageManager.Close()
		dbCleanup()
	}

	return handlers, router, fileRepo, storageManager, cleanup
}

// ========== UPLOAD FILE TESTS ==========

func TestHandlers_UploadFile_JSON_Success(t *testing.T) {
	t.Parallel()
	_, router, _, _, cleanup := setupFileHandlersTest(t)
	defer cleanup()

	// Create base64 encoded file data
	fileContent := []byte("Hello, World! This is test file content.")
	base64Content := base64.StdEncoding.EncodeToString(fileContent)

	req := map[string]interface{}{
		"file_name":    "test.txt",
		"file_data":    base64Content,
		"mime_type":    "text/plain",
		"access_scope": "workflow",
		"tags":         []string{"test", "example"},
	}

	w := testutil.MakeRequest(t, router, "POST", "/api/v1/files", req)

	assert.Equal(t, http.StatusCreated, w.Code)

	var result map[string]interface{}
	testutil.ParseResponse(t, w, &result)

	assert.NotEmpty(t, result["id"])
	assert.Equal(t, "test.txt", result["name"])
	assert.Equal(t, "text/plain", result["mime_type"])
	assert.Equal(t, "workflow", result["access_scope"])
	assert.Equal(t, float64(len(fileContent)), result["size"])
}

func TestHandlers_UploadFile_JSON_AutoGeneratedFilename(t *testing.T) {
	t.Parallel()
	_, router, _, _, cleanup := setupFileHandlersTest(t)
	defer cleanup()

	base64Content := base64.StdEncoding.EncodeToString([]byte("test content"))

	req := map[string]interface{}{
		"file_data": base64Content,
		"mime_type": "text/plain",
	}

	w := testutil.MakeRequest(t, router, "POST", "/api/v1/files", req)

	// Handler auto-generates filename if missing
	assert.Equal(t, http.StatusCreated, w.Code)

	var result map[string]interface{}
	testutil.ParseResponse(t, w, &result)
	assert.NotEmpty(t, result["id"])
	assert.NotEmpty(t, result["name"]) // Auto-generated name like "file_abc12345"
}

func TestHandlers_UploadFile_JSON_MissingData(t *testing.T) {
	t.Parallel()
	_, router, _, _, cleanup := setupFileHandlersTest(t)
	defer cleanup()

	req := map[string]interface{}{
		"file_name": "test.txt",
		"mime_type": "text/plain",
	}

	w := testutil.MakeRequest(t, router, "POST", "/api/v1/files", req)

	testutil.AssertErrorResponse(t, w, http.StatusBadRequest, "either file_data or file_url is required")
}

func TestHandlers_UploadFile_JSON_InvalidBase64(t *testing.T) {
	t.Parallel()
	_, router, _, _, cleanup := setupFileHandlersTest(t)
	defer cleanup()

	req := map[string]interface{}{
		"file_name": "test.txt",
		"file_data": "not-valid-base64!!!",
		"mime_type": "text/plain",
	}

	w := testutil.MakeRequest(t, router, "POST", "/api/v1/files", req)

	testutil.AssertErrorResponse(t, w, http.StatusBadRequest, "invalid base64 data")
}

func TestHandlers_UploadFile_Multipart_Success(t *testing.T) {
	t.Parallel()
	_, router, _, _, cleanup := setupFileHandlersTest(t)
	defer cleanup()

	// Create multipart form data
	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)

	// Add file - use PNG magic bytes to get image/png MIME type
	fileContent := []byte{0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D}
	part, err := writer.CreateFormFile("file", "multipart-test.png")
	require.NoError(t, err)
	_, err = part.Write(fileContent)
	require.NoError(t, err)

	// Add metadata fields
	writer.WriteField("access_scope", "workflow")
	writer.WriteField("tags", "tag1,tag2")

	err = writer.Close()
	require.NoError(t, err)

	// Make request
	req := httptest.NewRequest("POST", "/api/v1/files", body)
	req.Header.Set("Content-Type", writer.FormDataContentType())
	w := httptest.NewRecorder()

	router.ServeHTTP(w, req)

	if w.Code != http.StatusCreated {
		t.Logf("Response body: %s", w.Body.String())
	}
	assert.Equal(t, http.StatusCreated, w.Code)

	var result map[string]interface{}
	testutil.ParseResponse(t, w, &result)

	assert.NotEmpty(t, result["id"])
	assert.Equal(t, "multipart-test.png", result["name"])
	assert.Equal(t, "workflow", result["access_scope"])
	assert.Equal(t, float64(len(fileContent)), result["size"])
}

// ========== GET FILE TESTS ==========

func TestHandlers_GetFile_Success(t *testing.T) {
	t.Parallel()
	_, router, _, _, cleanup := setupFileHandlersTest(t)
	defer cleanup()

	// Upload a file first
	fileContent := []byte("Download test content")
	base64Content := base64.StdEncoding.EncodeToString(fileContent)

	uploadReq := map[string]interface{}{
		"file_name": "download-test.txt",
		"file_data": base64Content,
		"mime_type": "text/plain",
	}

	uploadW := testutil.MakeRequest(t, router, "POST", "/api/v1/files", uploadReq)
	require.Equal(t, http.StatusCreated, uploadW.Code)

	var uploadResult map[string]interface{}
	testutil.ParseResponse(t, uploadW, &uploadResult)
	fileID := uploadResult["id"].(string)

	// Download the file
	downloadW := testutil.MakeRequest(t, router, "GET", fmt.Sprintf("/api/v1/files/%s", fileID), nil)

	assert.Equal(t, http.StatusOK, downloadW.Code)
	assert.Equal(t, "text/plain", downloadW.Header().Get("Content-Type"))
	assert.Equal(t, `attachment; filename="download-test.txt"`, downloadW.Header().Get("Content-Disposition"))
	assert.Equal(t, fileContent, downloadW.Body.Bytes())
}

func TestHandlers_GetFile_NotFound(t *testing.T) {
	t.Parallel()
	_, router, _, _, cleanup := setupFileHandlersTest(t)
	defer cleanup()

	randomID := uuid.New().String()
	w := testutil.MakeRequest(t, router, "GET", fmt.Sprintf("/api/v1/files/%s", randomID), nil)

	testutil.AssertErrorResponse(t, w, http.StatusNotFound, "")
}

func TestHandlers_GetFile_InvalidID(t *testing.T) {
	t.Parallel()
	_, router, _, _, cleanup := setupFileHandlersTest(t)
	defer cleanup()

	w := testutil.MakeRequest(t, router, "GET", "/api/v1/files/invalid-uuid", nil)

	testutil.AssertErrorResponse(t, w, http.StatusBadRequest, "invalid file ID")
}

// ========== GET FILE METADATA TESTS ==========

func TestHandlers_GetFileMetadata_Success(t *testing.T) {
	t.Parallel()
	_, router, _, _, cleanup := setupFileHandlersTest(t)
	defer cleanup()

	// Upload a file first
	fileContent := []byte("Metadata test content")
	base64Content := base64.StdEncoding.EncodeToString(fileContent)

	uploadReq := map[string]interface{}{
		"file_name":    "metadata-test.txt",
		"file_data":    base64Content,
		"mime_type":    "text/plain",
		"access_scope": "edge",
		"tags":         []string{"meta", "test"},
	}

	uploadW := testutil.MakeRequest(t, router, "POST", "/api/v1/files", uploadReq)
	require.Equal(t, http.StatusCreated, uploadW.Code)

	var uploadResult map[string]interface{}
	testutil.ParseResponse(t, uploadW, &uploadResult)
	fileID := uploadResult["id"].(string)

	// Get metadata
	metadataW := testutil.MakeRequest(t, router, "GET", fmt.Sprintf("/api/v1/files/%s/metadata", fileID), nil)

	assert.Equal(t, http.StatusOK, metadataW.Code)

	var result map[string]interface{}
	testutil.ParseResponse(t, metadataW, &result)

	assert.Equal(t, fileID, result["id"])
	assert.Equal(t, "metadata-test.txt", result["name"])
	assert.Equal(t, "text/plain", result["mime_type"])
	assert.Equal(t, "edge", result["access_scope"])
	assert.Equal(t, float64(len(fileContent)), result["size"])
}

func TestHandlers_GetFileMetadata_NotFound(t *testing.T) {
	t.Parallel()
	_, router, _, _, cleanup := setupFileHandlersTest(t)
	defer cleanup()

	randomID := uuid.New().String()
	w := testutil.MakeRequest(t, router, "GET", fmt.Sprintf("/api/v1/files/%s/metadata", randomID), nil)

	testutil.AssertErrorResponse(t, w, http.StatusNotFound, "")
}

// ========== DELETE FILE TESTS ==========

func TestHandlers_DeleteFile_Success(t *testing.T) {
	t.Parallel()
	_, router, _, _, cleanup := setupFileHandlersTest(t)
	defer cleanup()

	// Upload a file first
	base64Content := base64.StdEncoding.EncodeToString([]byte("Delete test content"))

	uploadReq := map[string]interface{}{
		"file_name": "delete-test.txt",
		"file_data": base64Content,
		"mime_type": "text/plain",
	}

	uploadW := testutil.MakeRequest(t, router, "POST", "/api/v1/files", uploadReq)
	require.Equal(t, http.StatusCreated, uploadW.Code)

	var uploadResult map[string]interface{}
	testutil.ParseResponse(t, uploadW, &uploadResult)
	fileID := uploadResult["id"].(string)

	// Delete the file
	deleteW := testutil.MakeRequest(t, router, "DELETE", fmt.Sprintf("/api/v1/files/%s", fileID), nil)

	assert.Equal(t, http.StatusOK, deleteW.Code)

	// Verify file is deleted
	getW := testutil.MakeRequest(t, router, "GET", fmt.Sprintf("/api/v1/files/%s", fileID), nil)
	assert.Equal(t, http.StatusNotFound, getW.Code)
}

func TestHandlers_DeleteFile_NotFound(t *testing.T) {
	t.Parallel()
	_, router, _, _, cleanup := setupFileHandlersTest(t)
	defer cleanup()

	randomID := uuid.New().String()
	w := testutil.MakeRequest(t, router, "DELETE", fmt.Sprintf("/api/v1/files/%s", randomID), nil)

	testutil.AssertErrorResponse(t, w, http.StatusNotFound, "")
}

// ========== LIST FILES TESTS ==========

func TestHandlers_ListFiles_Empty(t *testing.T) {
	t.Parallel()
	_, router, _, _, cleanup := setupFileHandlersTest(t)
	defer cleanup()

	w := testutil.MakeRequest(t, router, "GET", "/api/v1/files", nil)

	assert.Equal(t, http.StatusOK, w.Code)

	var result map[string]interface{}
	testutil.ParseResponse(t, w, &result)

	files := result["files"].([]interface{})
	assert.Empty(t, files)
	assert.Equal(t, float64(0), result["total"])
}

func TestHandlers_ListFiles_WithData(t *testing.T) {
	t.Parallel()
	_, router, _, _, cleanup := setupFileHandlersTest(t)
	defer cleanup()

	// Upload 3 files
	for i := 1; i <= 3; i++ {
		base64Content := base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("File %d content", i)))

		req := map[string]interface{}{
			"file_name": fmt.Sprintf("file%d.txt", i),
			"file_data": base64Content,
			"mime_type": "text/plain",
		}

		uploadW := testutil.MakeRequest(t, router, "POST", "/api/v1/files", req)
		require.Equal(t, http.StatusCreated, uploadW.Code)
	}

	// List files
	w := testutil.MakeRequest(t, router, "GET", "/api/v1/files", nil)

	assert.Equal(t, http.StatusOK, w.Code)

	var result map[string]interface{}
	testutil.ParseResponse(t, w, &result)

	files := result["files"].([]interface{})
	assert.Len(t, files, 3)
	assert.Equal(t, float64(3), result["total"])
}

func TestHandlers_ListFiles_FilterByScope(t *testing.T) {
	t.Parallel()
	_, router, _, _, cleanup := setupFileHandlersTest(t)
	defer cleanup()

	// Upload files with different scopes
	scopes := []string{"workflow", "edge", "workflow"}
	for i, scope := range scopes {
		base64Content := base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("File %d content", i)))

		req := map[string]interface{}{
			"file_name":    fmt.Sprintf("file%d.txt", i),
			"file_data":    base64Content,
			"mime_type":    "text/plain",
			"access_scope": scope,
		}

		uploadW := testutil.MakeRequest(t, router, "POST", "/api/v1/files", req)
		require.Equal(t, http.StatusCreated, uploadW.Code)
	}

	// List files filtered by workflow
	w := testutil.MakeRequest(t, router, "GET", "/api/v1/files?access_scope=workflow", nil)

	assert.Equal(t, http.StatusOK, w.Code)

	var result map[string]interface{}
	testutil.ParseResponse(t, w, &result)

	files := result["files"].([]interface{})
	assert.Len(t, files, 2)
	assert.Equal(t, float64(2), result["total"])
}

func TestHandlers_ListFiles_Pagination(t *testing.T) {
	t.Parallel()
	_, router, _, _, cleanup := setupFileHandlersTest(t)
	defer cleanup()

	// Upload 5 files
	for i := 1; i <= 5; i++ {
		base64Content := base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("File %d content", i)))

		req := map[string]interface{}{
			"file_name": fmt.Sprintf("file%d.txt", i),
			"file_data": base64Content,
			"mime_type": "text/plain",
		}

		uploadW := testutil.MakeRequest(t, router, "POST", "/api/v1/files", req)
		require.Equal(t, http.StatusCreated, uploadW.Code)
	}

	// Get first page (limit=2)
	w := testutil.MakeRequest(t, router, "GET", "/api/v1/files?limit=2&offset=0", nil)

	assert.Equal(t, http.StatusOK, w.Code)

	var result map[string]interface{}
	testutil.ParseResponse(t, w, &result)

	files := result["files"].([]interface{})
	assert.Len(t, files, 2)
	assert.Equal(t, float64(5), result["total"])
}

// ========== GET STORAGE USAGE TESTS ==========

func TestHandlers_GetStorageUsage_Success(t *testing.T) {
	t.Parallel()
	_, router, _, _, cleanup := setupFileHandlersTest(t)
	defer cleanup()

	// Upload files
	file1Size := len("File 1 content - larger")
	file2Size := len("File 2")

	uploadReq1 := map[string]interface{}{
		"file_name": "file1.txt",
		"file_data": base64.StdEncoding.EncodeToString([]byte("File 1 content - larger")),
		"mime_type": "text/plain",
	}
	uploadW1 := testutil.MakeRequest(t, router, "POST", "/api/v1/files", uploadReq1)
	require.Equal(t, http.StatusCreated, uploadW1.Code)

	uploadReq2 := map[string]interface{}{
		"file_name": "file2.txt",
		"file_data": base64.StdEncoding.EncodeToString([]byte("File 2")),
		"mime_type": "text/plain",
	}
	uploadW2 := testutil.MakeRequest(t, router, "POST", "/api/v1/files", uploadReq2)
	require.Equal(t, http.StatusCreated, uploadW2.Code)

	// Get storage usage
	w := testutil.MakeRequest(t, router, "GET", "/api/v1/files/usage", nil)

	assert.Equal(t, http.StatusOK, w.Code)

	var result map[string]interface{}
	testutil.ParseResponse(t, w, &result)

	assert.Equal(t, float64(2), result["file_count"])
	assert.Equal(t, float64(file1Size+file2Size), result["total_size"])
}

func TestHandlers_GetStorageUsage_FilterByScope(t *testing.T) {
	t.Parallel()
	_, router, _, _, cleanup := setupFileHandlersTest(t)
	defer cleanup()

	// Upload files with different scopes
	uploadReq1 := map[string]interface{}{
		"file_name":    "workflow-file.txt",
		"file_data":    base64.StdEncoding.EncodeToString([]byte("Workflow content")),
		"mime_type":    "text/plain",
		"access_scope": "workflow",
	}
	uploadW1 := testutil.MakeRequest(t, router, "POST", "/api/v1/files", uploadReq1)
	require.Equal(t, http.StatusCreated, uploadW1.Code)

	uploadReq2 := map[string]interface{}{
		"file_name":    "edge-file.txt",
		"file_data":    base64.StdEncoding.EncodeToString([]byte("Edge content")),
		"mime_type":    "text/plain",
		"access_scope": "edge",
	}
	uploadW2 := testutil.MakeRequest(t, router, "POST", "/api/v1/files", uploadReq2)
	require.Equal(t, http.StatusCreated, uploadW2.Code)

	// Get storage usage for workflow scope
	w := testutil.MakeRequest(t, router, "GET", "/api/v1/files/usage?access_scope=workflow", nil)

	assert.Equal(t, http.StatusOK, w.Code)

	var result map[string]interface{}
	testutil.ParseResponse(t, w, &result)

	assert.Equal(t, float64(1), result["file_count"])
	assert.Equal(t, "workflow", result["access_scope"])
}
