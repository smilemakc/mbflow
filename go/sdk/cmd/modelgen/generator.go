package main

import (
	"bytes"
	"fmt"
	"go/format"
)

// Generate produces formatted Go source code from a parsed file.
func Generate(rule FileRule, parsed *ParsedFile) ([]byte, error) {
	var buf bytes.Buffer

	// Header
	fmt.Fprintf(&buf, "// Code generated by modelgen from pkg/models/%s. DO NOT EDIT.\n\n", rule.SourceFile)

	// Package
	buf.WriteString("package models\n\n")

	// Imports
	if parsed.NeedsTime {
		buf.WriteString("import \"time\"\n\n")
	}

	// Declarations in source order
	for _, decl := range parsed.Decls {
		switch d := decl.(type) {
		case *TypeAliasDecl:
			writeTypeAlias(&buf, d)
		case *ConstBlockDecl:
			writeConstBlock(&buf, d)
		case *StructDecl:
			writeStruct(&buf, d)
		}
	}

	return format.Source(buf.Bytes())
}

func writeTypeAlias(buf *bytes.Buffer, ta *TypeAliasDecl) {
	if ta.Doc != "" {
		buf.WriteString(ta.Doc)
	}
	fmt.Fprintf(buf, "type %s %s\n\n", ta.Name, ta.Underlying)
}

func writeConstBlock(buf *bytes.Buffer, cb *ConstBlockDecl) {
	if cb.Doc != "" {
		buf.WriteString(cb.Doc)
	}
	buf.WriteString("const (\n")
	for _, c := range cb.Consts {
		if c.Doc != "" {
			buf.WriteString(c.Doc)
		}
		if c.Type != "" && c.Value != "" {
			fmt.Fprintf(buf, "\t%s %s = %s", c.Name, c.Type, c.Value)
		} else if c.Value != "" {
			fmt.Fprintf(buf, "\t%s = %s", c.Name, c.Value)
		} else {
			fmt.Fprintf(buf, "\t%s", c.Name)
		}
		if c.Comment != "" {
			fmt.Fprintf(buf, " // %s", c.Comment)
		}
		buf.WriteString("\n")
	}
	buf.WriteString(")\n\n")
}

func writeStruct(buf *bytes.Buffer, s *StructDecl) {
	if s.Doc != "" {
		buf.WriteString(s.Doc)
	}
	fmt.Fprintf(buf, "type %s struct {\n", s.Name)
	for _, f := range s.Fields {
		fmt.Fprintf(buf, "\t%s %s", f.Name, f.Type)
		if f.Tag != "" {
			fmt.Fprintf(buf, " %s", f.Tag)
		}
		if f.Comment != "" {
			fmt.Fprintf(buf, " // %s", f.Comment)
		}
		buf.WriteString("\n")
	}
	buf.WriteString("}\n\n")
}
