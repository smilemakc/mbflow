import { useUIStore } from './uiStore';

const dictionaries = {
  en: {
    common: {
      save: "Save",
      run: "Run",
      running: "Running...",
      undo: "Undo",
      redo: "Redo",
      saved: "Saved",
      unsaved: "Unsaved",
      saving: "Saving...",
      lastSaved: "Last saved",
      delete: "Delete",
      cancel: "Cancel",
      search: "Search...",
      loading: "Loading",
      error: "Error",
      success: "Success",
      unknown: "Unknown",
      edit: "Edit",
      back: "Back",
      close: "Close",
      retry: "Retry",
      name: "Name",
      description: "Description",
      status: "Status",
      refresh: "Refresh",
      created: "Created",
      actions: "Actions",
      create: "Create",
      previous: "Previous",
      next: "Next"
    },
    sidebar: {
      dashboard: "Dashboard",
      workflows: "Workflows",
      executions: "Executions",
      triggers: "Triggers",
      monitoring: "Monitoring",
      resources: "Resources",
      settings: "Settings",
      signOut: "Sign Out",
      title: "Workflow.ai"
    },
    dashboard: {
      title: "Dashboard Overview",
      subtitle: "Monitor your automation health and performance.",
      totalWorkflows: "Total Workflows",
      executionsToday: "Executions Today",
      successRate: "Success Rate",
      avgDuration: "Avg Duration",
      recentActivity: "Recent Activity",
      viewAll: "View All",
      systemHealth: "System Health",
      quickActions: "Ready to build?",
      createWorkflow: "Create New Workflow",
      quickDesc: "Create a new workflow using the visual editor.",
      table: {
        workflow: "Workflow",
        status: "Status",
        duration: "Duration",
        triggeredBy: "Triggered By",
        time: "Time"
      }
    },
    builder: {
      components: "Components",
      dragToAdd: "Drag to add",
      triggers: "TRIGGERS",
      actions: "ACTIONS",
      telegram: "TELEGRAM",
      logic: "LOGIC",
      storage: "STORAGE",
      adapters: "ADAPTERS",
      properties: "Properties",
      general: "General",
      name: "Name",
      description: "Description",
      deleteNode: "Delete Node",
      nodeConfig: "Config",
      noConfigAvailable: "No specific configuration available for this node type."
    },
    monitoring: {
      title: "Execution Monitor",
      consoleLogs: "Console Logs",
      io: "Inputs / Outputs",
      clear: "Clear Logs",
      ready: "Ready to execute. Click 'Run' to start.",
      inputs: "INPUTS",
      outputs: "OUTPUTS",
      selectNode: "Select a node to view its inputs and outputs."
    },
    settings: {
      title: "Settings",
      profile: "Profile",
      notifications: "Notifications",
      security: "Security",
      billing: "Billing",
      appearance: "Appearance",
      profileInfo: "Profile Information",
      profileDesc: "Update your account details and email.",
      firstName: "First Name",
      lastName: "Last Name",
      email: "Email Address",
      bio: "Bio",
      saveChanges: "Save Changes"
    },
    nodes: {
      // Triggers
      delay: "Delay / Scheduler",

      // Actions
      http: "HTTP Request",
      llm: "LLM / AI",
      transform: "Transform",
      functionCall: "Function Call",

      // Telegram
      telegram: "Telegram Send",
      telegramDownload: "TG Download",
      telegramParse: "TG Parse",
      telegramCallback: "TG Callback",

      // Logic
      conditional: "Conditional",
      merge: "Merge",

      // Storage
      fileStorage: "File Storage",

      // Adapters
      HTMLCleaner: "HTML cleaner",
      base64ToBytes: "Base64 → Bytes",
      bytesToBase64: "Bytes → Base64",
      stringToJson: "String → JSON",
      jsonToString: "JSON → String",
      bytesToJson: "Bytes → JSON",
      fileToBytes: "File → Bytes",
      bytesToFile: "Bytes → File",
      csvToJson: "CSV → JSON",

      // External integrations
      googleSheets: "Google Sheets",
      googleDrive: "Google Drive",

      // Legacy keys (for backwards compatibility)
      scheduler: "Scheduler",
      telegramBot: "Telegram Bot",
      apiRequest: "HTTP Request",
      aiGenerator: "AI Generator",
      condition: "Condition"
    },
    executions: {
      title: "Execution History",
      subtitle: "View and manage all workflow executions",
      filters: "Filters",
      allWorkflows: "All Workflows",
      allStatuses: "All Statuses",
      dateRange: "Date Range",
      applyFilters: "Apply Filters",
      clearFilters: "Clear Filters",
      table: {
        id: "ID",
        workflow: "Workflow",
        status: "Status",
        startedAt: "Started At",
        duration: "Duration",
        triggeredBy: "Triggered By",
        actions: "Actions"
      },
      status: {
        pending: "Pending",
        running: "Running",
        completed: "Completed",
        failed: "Failed",
        cancelled: "Cancelled"
      },
      actions: {
        viewDetails: "View Details",
        retry: "Retry",
        cancel: "Cancel"
      },
      details: {
        title: "Execution Details",
        overview: "Overview",
        nodeExecutions: "Node Executions",
        logs: "Logs",
        input: "Input",
        output: "Output",
        error: "Error",
        close: "Close"
      },
      noData: "No executions found",
      loadMore: "Load More",
      pagination: {
        showing: "Showing",
        of: "of",
        results: "results"
      }
    },
    executionDetail: {
      title: "Execution Details",
      backToList: "Back to Executions",
      refresh: "Refresh",
      copy: "Copy",
      copied: "Copied!",
      noData: "No data",
      fields: "fields",
      error: "Error",
      input: "Input",
      output: "Output",
      startedAt: "Started At",
      completedAt: "Completed At",
      retryCount: "Retry Count",
      totalNodes: "Total Nodes",
      nodeExecutions: "Node Executions",
      nodeExecutionsDesc: "Click on a node to view its inputs and outputs",
      expandAll: "Expand All",
      collapseAll: "Collapse All",
      noNodeExecutions: "No node executions found",
      overview: "Overview",
      metadata: "Metadata",
      variables: "Variables",
      executionError: "Execution Error",
      notFound: "Execution not found",
      fetchError: "Failed to load execution details",
      retryStarted: "Retry started",
      retryFailed: "Failed to retry execution"
    },
    auth: {
      signIn: "Sign In",
      signUp: "Sign Up",
      signOut: "Sign Out",
      signInDescription: "Enter your credentials to access your account",
      signUpDescription: "Create a new account to get started",
      signingIn: "Signing in...",
      creatingAccount: "Creating account...",
      createAccount: "Create Account",
      email: "Email",
      password: "Password",
      confirmPassword: "Confirm Password",
      username: "Username",
      fullName: "Full Name",
      noAccount: "Don't have an account?",
      alreadyHaveAccount: "Already have an account?",
      passwordsDoNotMatch: "Passwords do not match",
      passwordTooShort: "Password must be at least 8 characters",
      usernameTooShort: "Username must be at least 3 characters",
      usernameHint: "Letters, numbers, underscores and hyphens only",
      passwordHint: "At least 8 characters with uppercase, lowercase, and number"
    },
    nav: {
      settings: "Settings",
      userManagement: "User Management",
      rentalKeys: "Rental Keys"
    },
    admin: {
      userManagement: "User Management",
      userManagementDescription: "Manage users and their roles",
      addUser: "Add User",
      user: "User",
      email: "Email",
      roles: "Roles",
      status: "Status",
      actions: "Actions",
      active: "Active",
      inactive: "Inactive",
      activate: "Activate",
      deactivate: "Deactivate",
      edit: "Edit",
      loadError: "Failed to load users",
      userDeleted: "User deleted successfully",
      deleteError: "Failed to delete user",
      userActivated: "User activated",
      userDeactivated: "User deactivated",
      updateError: "Failed to update user",
      pagination: {
        showing: "Showing",
        to: "to",
        of: "of",
        users: "users",
        previous: "Previous",
        next: "Next"
      },
      deleteModal: {
        title: "Delete User",
        message: "Are you sure you want to delete this user? This action cannot be undone.",
        confirm: "Delete"
      },
      // Rental Keys Admin
      rentalKeysManagement: "Rental Keys Management",
      createKey: "Create Key",
      createRentalKey: "Create Rental Key",
      editRentalKey: "Edit Rental Key",
      deleteRentalKey: "Delete Rental Key",
      deleteRentalKeyConfirm: "Are you sure you want to delete",
      rotateAPIKey: "Rotate API Key",
      rotateKey: "Rotate Key",
      rotatingKeyFor: "Rotating key for",
      rotateKeyWarningTitle: "Warning",
      rotateKeyWarning: "Rotating the API key will immediately invalidate the old key. Any workflows using this rental key will start using the new key on their next execution.",
      newAPIKey: "New API Key",
      newAPIKeyHint: "This key will be encrypted and never shown again.",
      owner: "Owner",
      allProviders: "All Providers",
      allStatuses: "All Statuses",
      filterByOwner: "Filter by Owner ID...",
      noRentalKeys: "No rental keys found",
      createFirstKey: "Create your first rental key to get started",
      showingOf: "Showing",
      of: "of",
      usage: "Usage",
      dailyRequestLimit: "Daily Request Limit",
      monthlyTokenLimit: "Monthly Token Limit",
      apiKey: "API Key",
      apiKeyHint: "The API key will be encrypted and stored securely.",
      provisionerType: "Provisioner Type",
      selectOwner: "Select Owner",
      enterOwnerId: "Enter Owner ID",
      ownerUserId: "Owner (User ID)",
      ownerUser: "Owner",
      selectUser: "Select user...",
      searchUsers: "Search users...",
      noUsersFound: "No users found",
      allOwners: "All Owners",
      provider: "Provider"
    },
    workflows: {
      title: "Workflows",
      subtitle: "Manage and organize your automation workflows.",
      createNew: "Create New Workflow",
      variablesGuide: "Variables Guide",
      searchPlaceholder: "Search workflows by name or description...",
      allStatus: "All Status",
      draft: "Draft",
      active: "Active",
      inactive: "Inactive",
      archived: "Archived",
      showing: "Showing",
      workflow: "workflow",
      workflowsCount: "workflows",
      matching: "matching",
      tryAgain: "Try Again",
      noWorkflowsFound: "No workflows found",
      noWorkflowsYet: "No workflows yet",
      adjustFilters: "Try adjusting your search or filter criteria.",
      getStarted: "Get started by creating your first workflow.",
      createFirst: "Create Your First Workflow",
      edit: "Edit",
      cloneTooltip: "Clone workflow",
      deleteTooltip: "Delete workflow",
      previous: "Previous",
      next: "Next",
      node: "node",
      nodesCount: "nodes",
      created: "Created",
      updated: "Updated",
      today: "Today",
      yesterday: "Yesterday",
      daysAgo: "days ago",
      deleteModal: {
        title: "Delete Workflow",
        message: "Are you sure you want to delete this workflow? This action cannot be undone.",
        confirm: "Delete"
      },
      errors: {
        cloneFailed: "Clone Failed",
        cloneMessage: "Failed to clone workflow. Please try again.",
        deleteFailed: "Delete Failed",
        deleteMessage: "Failed to delete workflow. Please try again."
      }
    },
    triggers: {
      title: "Triggers",
      subtitle: "Manage workflow triggers and execution schedules",
      createTrigger: "Create Trigger",
      filter: "Filter:",
      allTypes: "All Types",
      manual: "Manual",
      schedule: "Schedule",
      webhook: "Webhook",
      event: "Event",
      allStatus: "All Status",
      enabled: "Enabled",
      disabled: "Disabled",
      ofTriggers: "of",
      triggersCount: "triggers",
      noTriggersFound: "No triggers found",
      adjustFilters: "Try adjusting your filters",
      createFirst: "Create your first trigger to automate workflow execution",
      table: {
        name: "Name",
        type: "Type",
        workflow: "Workflow",
        status: "Status",
        nextRun: "Next Run",
        lastTriggered: "Last Triggered",
        actions: "Actions"
      },
      executeNow: "Execute Now",
      edit: "Edit",
      never: "Never",
      overdue: "Overdue",
      inMinutes: "in {n} mins",
      inHours: "in {n} hours",
      inDays: "in {n} days",
      createModal: {
        title: "Create New Trigger",
        placeholder: "Trigger creation form will be implemented here."
      },
      editModal: {
        title: "Edit Trigger",
        editing: "Editing trigger:"
      },
      deleteModal: {
        title: "Delete Trigger",
        message: "Are you sure you want to delete this trigger? This action cannot be undone.",
        confirm: "Delete"
      }
    },
    resources: {
      pageTitle: "Resources & Billing",
      pageSubtitle: "Manage your file storage resources and account balance.",
      accountBalance: "Account Balance",
      fileStorageResources: "File Storage Resources",
      createStorage: "Create Storage",
      noStorageYet: "No storage resources yet",
      noStorageDescription: "Create your first file storage resource to get started.",
      storageUsage: "Storage Usage",
      files: "files",
      file: "file",
      used: "used",
      created: "Created",
      viewFiles: "View Files",
      createStorageTitle: "Create File Storage",
      storageName: "Storage Name",
      storageNamePlaceholder: "e.g., Production Storage",
      description: "Description",
      descriptionPlaceholder: "Optional description...",
      create: "Create",
      depositFundsTitle: "Deposit Funds",
      deposit: "Deposit",
      amount: "Amount",
      amountPlaceholder: "0.00",
      amountHint: "Enter the amount you want to add to your account balance",
      filesTitle: "Files",
      chooseFile: "Choose file to upload",
      upload: "Upload",
      fileSize: "File size",
      noFilesYet: "No files uploaded yet",
      showingFiles: "Showing",
      ofFiles: "of",
      totalFiles: "files",
      totalSize: "Total",
      deleteFileTitle: "Delete File",
      deleteFileMessage: "Are you sure you want to delete this file? This action cannot be undone.",
      deleteResourceTitle: "Delete Resource",
      deleteResourceMessage: "Are you sure you want to delete this resource? This action cannot be undone.",
      billingTransactions: "Billing & Transactions",
      depositFunds: "Deposit Funds",
      transactionHistory: "Transaction History",
      showingTransactions: "Showing",
      ofTotal: "of",
      totalTransactions: "total transactions",
      noTransactionsYet: "No transactions yet",
      type: "Type",
      transactionDescription: "Description",
      transactionAmount: "Amount",
      status: "Status",
      date: "Date",
      transactionTypes: {
        deposit: "Deposit",
        charge: "Charge",
        refund: "Refund",
        storage: "Storage"
      },
      statuses: {
        active: "Active",
        inactive: "Inactive",
        completed: "Completed",
        pending: "Pending",
        failed: "Failed"
      }
    },
    credentials: {
      title: "Credentials",
      create: "Create Credential",
      createTitle: "Create New Credential",
      editTitle: "Edit Credential",
      name: "Name",
      namePlaceholder: "e.g., OpenAI API Key",
      description: "Description",
      descriptionPlaceholder: "Optional description...",
      provider: "Provider",
      type: "Type",
      allTypes: "All Types",
      filterByProvider: "Filter by provider...",
      usageCount: "Usage",
      created: "Created",
      lastUsed: "Last used",
      expires: "Expires",
      expired: "Expired",
      viewSecrets: "View Secrets",
      emptyTitle: "No credentials yet",
      emptyDescription: "Create your first credential to securely store API keys and secrets.",
      createFirst: "Create Your First Credential",
      deleteTitle: "Delete Credential",
      deleteConfirmation: "Are you sure you want to delete \"{name}\"? This action cannot be undone.",
      secretsWarningTitle: "Sensitive Information",
      secretsWarningText: "These secrets will be shown in plain text. Make sure no one is watching your screen.",
      expiredError: "This credential has expired",
      username: "Username",
      password: "Password",
      customFields: "Custom Fields",
      addField: "Add Field",
      apiKeyDescription: "Simple API key or token for accessing external services",
      basicAuthDescription: "Username and password combination for basic authentication",
      oauth2Description: "OAuth2 credentials with client ID, secret, and tokens",
      serviceAccountDescription: "Service account JSON key file (e.g., Google Cloud)",
      customDescription: "Custom key-value pairs for any type of credentials"
    },
    rentalKeys: {
      title: "Rental Keys",
      allProviders: "All Providers",
      noKeysTitle: "No Rental Keys",
      noKeysDescription: "You don't have any rental keys assigned yet. Contact your administrator to get access to LLM API keys.",
      noKeysForProvider: "No rental keys found for this provider.",
      provider: "Provider",
      status: "Status",
      dailyLimit: "Daily Limit",
      monthlyLimit: "Monthly Limit",
      requestsToday: "Requests Today",
      tokensThisMonth: "Tokens This Month",
      totalRequests: "Total Requests",
      totalCost: "Total Cost",
      lastUsed: "Last Used",
      viewUsage: "View Usage",
      usageHistory: "Usage History",
      usageSummary: "Usage Summary",
      noUsageData: "No usage data available",
      noUsageRecords: "No usage records found",
      showingRecords: "Showing records",
      model: "Model",
      tokens: "Tokens",
      cost: "Cost",
      time: "Time",
      unlimited: "Unlimited",
      nearLimit: "Near Limit",
      atLimit: "At Limit",
      dailyRequests: "Daily Requests",
      monthlyTokens: "Monthly Tokens",
      totalTokens: "Total Tokens",
      textTokens: "Text Tokens",
      imageTokens: "Image Tokens",
      audioTokens: "Audio Tokens",
      videoTokens: "Video Tokens"
    },
    status: {
      active: "Active",
      suspended: "Suspended",
      deleted: "Deleted"
    },
    templates: {
      title: "Workflow Templates",
      subtitle: "Start with a pre-built automation pattern with full configurations",
      searchPlaceholder: "Search templates...",
      allTemplates: "All Templates",
      basic: "Basic",
      telegram: "Telegram",
      aiLlm: "AI & LLM",
      dataProcessing: "Data Processing",
      use: "Use",
      nodesCount: "nodes",
      edgesCount: "edges",
      noResults: "No templates found matching your criteria",
      loadModal: {
        title: "Load Template",
        message: "This will replace your current workflow. Any unsaved changes will be lost. Continue?",
        confirm: "Load Template"
      }
    },
    shortcuts: {
      title: "Keyboard Shortcuts",
      saveWorkflow: "Save Workflow",
      runWorkflow: "Run Workflow",
      undo: "Undo",
      redo: "Redo",
      toggleFocusMode: "Toggle Focus Mode",
      deleteNode: "Delete Selected Node",
      toggleShortcuts: "Toggle Shortcuts",
      proTip: "Pro tip: You can also use Right-Click on the canvas for more options."
    },
    header: {
      untitledWorkflow: "Untitled Workflow",
      clickToEdit: "Click to edit workflow name",
      workflowVariables: "Workflow Variables",
      workflowResources: "Workflow Resources",
      templates: "Templates",
      shortcuts: "Shortcuts",
      switchLanguage: "Switch Language",
      focusMode: "Focus Mode",
      toggleTheme: "Toggle Theme"
    },
    canvas: {
      autoLayoutTopBottom: "Auto Layout (Top to Bottom)",
      autoLayoutLeftRight: "Auto Layout (Left to Right)"
    },
    edge: {
      title: "Edge Configuration",
      connection: "Connection",
      branch: "Branch",
      trueBranch: "True Branch",
      falseBranch: "False Branch",
      branchDescription: "Select which branch of the conditional node this edge follows.",
      conditionExpression: "Condition Expression",
      optional: "(optional)",
      conditionPlaceholder: "output.status == \"success\"",
      conditionDescription: "Use expr-lang syntax. Edge will only be followed if condition evaluates to true.",
      conditionExamples: "Condition Examples",
      saveChanges: "Save Changes",
      deleteEdge: "Delete Edge",
      deleteModal: {
        title: "Delete Edge",
        message: "Are you sure you want to delete this edge? This action cannot be undone.",
        confirm: "Delete"
      }
    },
    contextMenu: {
      duplicate: "Duplicate",
      copyId: "Copy ID",
      resetView: "Reset View"
    },
    variables: {
      title: "Workflow Variables",
      subtitle: "Define environment variables for this workflow",
      guide: "Variables Guide",
      usageHint: "Use {{env.VARIABLE_NAME}} in node configurations to reference these variables.",
      noVariables: "No variables defined yet",
      addFirst: "Add your first variable below",
      hideValue: "Hide value",
      showValue: "Show value",
      copyTemplate: "Copy template",
      edit: "Edit",
      namePlaceholder: "VARIABLE_NAME",
      valuePlaceholder: "Value...",
      add: "Add",
      namingRules: "Variable names should be UPPERCASE with underscores (e.g., API_KEY, BASE_URL)"
    },
    variablesGuide: {
      title: "Workflow Variables & Templates",
      subtitle: "Reference guide for using variables in your workflows",
      templateSyntax: "Template Syntax",
      templateDescription: "Use {{variable.path}} syntax to reference variables in node configurations. Templates are resolved before node execution.",
      envTitle: "Environment Variables (env)",
      envDescription: "Access workflow-level and execution-level variables. Execution variables override workflow variables.",
      inputTitle: "Input Variables (input)",
      inputDescription: "Access data passed from parent nodes. The input object contains merged outputs from all connected parent nodes.",
      nodeTitle: "Node Outputs (Direct Reference)",
      nodeDescription: "Reference output from specific nodes by their ID. Useful when you need data from a non-parent node.",
      transformModes: "Transform Modes",
      quickReference: "Quick Reference"
    },
    quickAdd: {
      searchPlaceholder: "Search nodes...",
      noResults: "No nodes found"
    },
    monitoringPanel: {
      selected: "Selected",
      live: "Live",
      offline: "Offline"
    },
    nodeConfig: {
      noDescription: "No description provided.",
      noConfig: "No specific configuration available for this node type.",
      deleteConfirm: "Are you sure you want to delete this node? This action cannot be undone.",
      http: {
        method: "HTTP Method",
        url: "URL",
        urlPlaceholder: "https://api.example.com/endpoint",
        urlHint: "Supports template variables: {{env.API_KEY}}, {{node.previous.result}}",
        headers: "Headers",
        headerKeyPlaceholder: "Content-Type",
        headerValuePlaceholder: "application/json",
        removeHeader: "Remove header",
        addHeader: "+ Add Header",
        body: "Body",
        bodyPlaceholder: "{\"key\": \"value\"}",
        bodyHint: "JSON format. Supports template variables.",
        timeout: "Timeout (seconds)",
        retryCount: "Retry Count",
        followRedirects: "Follow Redirects"
      },
      llm: {
        provider: "Provider",
        model: "Model",
        apiKey: "API Key",
        apiKeyPlaceholder: "{{env.openai_api_key}}",
        apiKeyHint: "Use templates like {{env.openai_api_key}} to reference workflow variables",
        systemPrompt: "System Prompt (Optional)",
        systemPromptPlaceholder: "Enter system instructions...",
        userPrompt: "User Prompt",
        userPromptPlaceholder: "Enter user prompt...",
        advancedSettings: "Advanced Settings",
        temperature: "Temperature",
        temperatureHint: "(0.0 - 2.0, default: 0.7)",
        maxTokens: "Max Tokens",
        maxTokensHint: "(Maximum response length)",
        topP: "Top P",
        topPHint: "(0.0 - 1.0, nucleus sampling)",
        frequencyPenalty: "Frequency Penalty",
        frequencyPenaltyHint: "(-2.0 - 2.0)",
        presencePenalty: "Presence Penalty",
        presencePenaltyHint: "(-2.0 - 2.0)",
        stopSequences: "Stop Sequences (one per line)",
        stopSequencesPlaceholder: "Enter stop sequences, one per line",
        responseFormat: "Response Format",
        responseFormatText: "Text",
        responseFormatJson: "JSON",
        timeout: "Timeout (seconds)",
        retryCount: "Retry Count"
      },
      transform: {
        title: "Transform Data",
        description: "Transform input data using various methods: passthrough, templates, expressions, or jq filters",
        transformationType: "Transformation Type",
        passthrough: "Passthrough",
        passthroughDesc: "Pass input data unchanged to the next node",
        template: "Template",
        templateDesc: "Use template syntax with variables like {{env.var}} or {{input.field}}",
        templateLabel: "Template String",
        templatePlaceholder: "Hello {{env.userName}}, your input is: {{input.data}}",
        templateExamples: "Template Examples:",
        expression: "Expression",
        expressionDesc: "Use expr-lang for complex transformations with access to input variable",
        expressionLabel: "Expression (expr-lang)",
        expressionPlaceholder: "input.field * 2",
        expressionExamples: "Expression Examples:",
        jq: "JQ Filter",
        jqDesc: "Use jq syntax for JSON transformations and queries",
        jqLabel: "JQ Filter",
        jqPlaceholder: ".field | select(.value > 0)",
        jqExamples: "JQ Examples:",
        timeout: "Timeout (seconds)"
      },
      telegram: {
        credentials: "Credentials",
        botToken: "Bot Token",
        botTokenPlaceholder: "{{env.TELEGRAM_BOT_TOKEN}}",
        chatId: "Chat ID",
        chatIdPlaceholder: "@channel_name or {{env.CHAT_ID}}",
        message: "Message",
        messageType: "Message Type",
        messageText: "Message Text",
        messageTextPlaceholder: "Hello world! {{input.data}}",
        caption: "Caption (Optional)",
        captionPlaceholder: "Media caption...",
        fileSettings: "File Settings",
        fileSource: "File Source",
        fileData: "File URL",
        fileId: "File ID",
        base64Data: "Base64 Data",
        fileDataPlaceholder: "https://example.com/image.jpg",
        fileName: "File Name (Optional)",
        fileNamePlaceholder: "image.jpg",
        parseMode: "Parse Mode",
        disableWebPagePreview: "Disable Web Page Preview",
        disableNotification: "Disable Notification",
        protectContent: "Protect Content (Prevent Forwarding)",
        timeout: "Timeout (seconds)"
      },
      telegramDownload: {
        credentials: "Credentials",
        botToken: "Bot Token",
        file: "File",
        fileId: "File ID",
        fileIdPlaceholder: "{{input.message.document.file_id}}",
        fileIdHint: "File ID from Telegram message (photo, document, audio, video, etc.)",
        outputFormat: "Output Format",
        outputFormatBase64: "Base64 (download content)",
        outputFormatUrl: "URL (link only)",
        timeout: "Timeout (seconds)"
      },
      telegramParse: {
        extractOptions: "Extract Options",
        extractFiles: "Extract Files",
        extractFilesHint: "(documents, photos, videos, audio)",
        extractCommands: "Extract Commands",
        extractCommandsHint: "(e.g., /start, /help)",
        extractEntities: "Extract Entities",
        extractEntitiesHint: "(mentions, hashtags, URLs)",
        infoText: "Selected options control what data is extracted from Telegram updates and made available in the node output."
      },
      telegramCallback: {
        credentials: "Credentials",
        botToken: "Bot Token",
        callbackQuery: "Callback Query",
        callbackQueryId: "Callback Query ID",
        callbackQueryIdPlaceholder: "{{input.callback_query_id}}",
        textResponse: "Text Response (Optional)",
        textResponsePlaceholder: "Request completed! {{input.result}}",
        showAlert: "Show as popup alert instead of notification",
        url: "URL (Optional)",
        urlPlaceholder: "https://example.com",
        cacheTime: "Cache Time (seconds)",
        timeout: "Timeout (seconds)"
      },
      conditional: {
        conditionExpression: "Condition Expression",
        conditionPlaceholder: "{{input.value}} > 0",
        conditionHint: "Use expr-lang syntax to evaluate conditions. Returns true/false.",
        examples: {
          title: "Expression Examples",
          numeric: "{{input.value}} > 100 - Numeric comparison",
          string: "{{input.status}} == \"active\" - String equality",
          multiple: "{{input.count}} > 0 && {{input.enabled}} - Multiple conditions",
          arrayLength: "len({{input.items}}) > 5 - Array length check"
        },
        notes: {
          title: "Important Notes",
          trueBranch: "True branch: Nodes connected via edge labeled \"true\" or default first edge",
          falseBranch: "False branch: Nodes connected via edge labeled \"false\" or second edge",
          execution: "If condition evaluates to true, only the true branch will execute",
          templates: "Templates like {{input.X}} are resolved before evaluation"
        },
        operators: {
          title: "Supported Operators",
          comparison: "Comparison",
          comparisonOps: "==, !=, >, <, >=, <=",
          logical: "Logical",
          logicalOps: "&&, ||, !",
          arithmetic: "Arithmetic",
          arithmeticOps: "+, -, *, /, %",
          functions: "Functions",
          functionsOps: "len(), contains(), matches()"
        }
      },
      merge: {
        mergeStrategy: "Merge Strategy",
        strategyFirst: "First (Use first available result)",
        strategyLast: "Last (Use last available result)",
        strategyAll: "All (Combine all results into array)",
        strategyCustom: "Custom (Use expression)",
        strategyHint: "Choose how to combine results from multiple parent nodes.",
        customExpression: "Custom Merge Expression",
        customExpressionPlaceholder: "[{{input.parent1}}, {{input.parent2}}]",
        customExpressionHint: "Use expr-lang to define custom merge logic."
      },
      delay: {
        title: "Delay Node",
        description: "Pause workflow execution for a specified duration",
        duration: "Duration",
        durationPlaceholder: "Enter duration",
        unitSeconds: "Seconds",
        unitMinutes: "Minutes",
        unitHours: "Hours",
        descriptionLabel: "Description",
        descriptionOptional: "(optional)",
        descriptionPlaceholder: "Add a note about why this delay is needed...",
        preview: "Preview",
        previewWait: "Wait"
      },
      fileStorage: {
        action: "Action",
        actionStore: "Store File",
        actionGet: "Get File",
        actionDelete: "Delete File",
        actionList: "List Files",
        actionMetadata: "Get Metadata",
        storageId: "Storage ID (optional)",
        storageIdPlaceholder: "default",
        storageIdHint: "Leave empty for default storage",
        fileSource: "File Source",
        sourceType: "Source Type",
        sourceTypeUrl: "URL",
        sourceTypeBase64: "Base64 Data",
        fileUrl: "File URL",
        fileUrlPlaceholder: "https://example.com/document.pdf or {{input.url}}",
        base64Data: "Base64 Data",
        base64Placeholder: "{{input.base64_data}}",
        fileName: "File Name",
        fileNamePlaceholder: "document.pdf or {{input.filename}}",
        mimeType: "MIME Type (optional)",
        mimeTypePlaceholder: "Auto-detected if empty",
        storageOptions: "Storage Options",
        accessScope: "Access Scope",
        accessScopeWorkflow: "Workflow",
        accessScopeEdge: "Edge (Connected Nodes)",
        accessScopeResult: "Result (Output Storage)",
        ttl: "TTL (seconds, 0 = no expiration)",
        ttlPlaceholder: "0",
        tags: "Tags (comma-separated)",
        tagsPlaceholder: "document, important",
        fileId: "File ID",
        fileIdPlaceholder: "{{input.file_id}}",
        filters: "Filters",
        allScopes: "All Scopes",
        tagsFilter: "Tags Filter (comma-separated)",
        limit: "Limit",
        limitPlaceholder: "100",
        offset: "Offset",
        offsetPlaceholder: "0"
      },
      functionCall: {
        functionName: "Function Name",
        functionNamePlaceholder: "my_function",
        arguments: "Arguments (JSON)",
        argumentsPlaceholder: "{\"key\": \"{{input.value}}\"}",
        argumentsHint: "Enter function arguments as JSON object. You can use template variables like {{env.api_key}} or {{input.user_id}}",
        timeout: "Timeout (seconds)"
      },
      googleSheets: {
        title: "Google Sheets",
        description: "Read, write, and append data to Google Sheets using service account credentials",
        operation: "Operation",
        operationRead: "Read",
        operationWrite: "Write (overwrite)",
        operationAppend: "Append",
        operationHint: "Choose whether to read, write (overwrite), or append data",
        spreadsheetId: "Spreadsheet ID",
        spreadsheetIdPlaceholder: "1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms",
        spreadsheetIdHint: "The ID from the spreadsheet URL (between /d/ and /edit)",
        sheetName: "Sheet Name",
        sheetNamePlaceholder: "Sheet1",
        sheetNameHint: "Optional. The name of the sheet tab (defaults to first sheet)",
        range: "Range (A1 notation)",
        rangePlaceholder: "A1:D10",
        rangeHint: "Optional. Cell range in A1 notation (e.g., A1:D10, B2:C5)",
        credentials: "Service Account Credentials (JSON)",
        credentialsPlaceholder: "{\"type\":\"service_account\",\"project_id\":\"...\",\"private_key\":\"...\",\"client_email\":\"...\"}",
        credentialsHint: "Full JSON credentials from Google Cloud Console service account",
        valueInputOption: "Value Input Option",
        valueInputOptionUserEntered: "User Entered (parse formulas, dates)",
        valueInputOptionRaw: "Raw (store as-is)",
        valueInputOptionHint: "How input values should be interpreted",
        majorDimension: "Major Dimension",
        majorDimensionRows: "Rows (default)",
        majorDimensionColumns: "Columns",
        majorDimensionHint: "How data arrays should be interpreted",
        columnMapping: "Column Mapping",
        columnMappingPlaceholder: "title, description, link, categories, pubDate",
        columnMappingHint: "Optional. Comma-separated list of field names to extract from objects in order.",
        inputDataFormat: "Input Data Format"
      },
      googleDrive: {
        title: "Google Drive",
        description: "Manage files and folders in Google Drive using service account credentials",
        operation: "Operation",
        operationCreateSpreadsheet: "Create Spreadsheet",
        operationCreateFolder: "Create Folder",
        operationListFiles: "List Files",
        operationDelete: "Delete File/Folder",
        operationMove: "Move File",
        operationCopy: "Copy File",
        operationHint: "Select the operation to perform on Google Drive",
        credentials: "Service Account Credentials (JSON)",
        credentialsPlaceholder: "{\"type\":\"service_account\",\"project_id\":\"...\",\"private_key\":\"...\",\"client_email\":\"...\"}",
        credentialsHint: "Full JSON credentials from Google Cloud Console service account",
        fileName: "File Name",
        fileNameOptional: "(optional)",
        fileNamePlaceholder: "Untitled Spreadsheet",
        fileNameHint: "Name for the new file",
        folderName: "Folder Name",
        folderNamePlaceholder: "Untitled Folder",
        folderNameHint: "Name for the new folder",
        fileId: "File ID",
        fileIdPlaceholder: "1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms",
        fileIdHint: "Google Drive file ID",
        parentFolderId: "Parent Folder ID",
        parentFolderIdPlaceholder: "Leave empty for root folder",
        parentFolderIdHint: "Folder where file/folder will be created",
        destinationFolderId: "Destination Folder ID",
        destinationFolderIdPlaceholder: "Destination folder ID",
        destinationFolderIdHint: "Folder ID where file will be moved/copied",
        maxResults: "Max Results",
        maxResultsHint: "Maximum number of files to return (default: 100)",
        orderBy: "Order By",
        orderByModifiedDesc: "Modified Time (newest first)",
        orderByModified: "Modified Time (oldest first)",
        orderByCreatedDesc: "Created Time (newest first)",
        orderByCreated: "Created Time (oldest first)",
        orderByName: "Name (A-Z)",
        orderByNameDesc: "Name (Z-A)",
        orderByHint: "Sort order for listed files",
        outputVariables: "Output Variables"
      },
      csvToJson: {
        title: "CSV → JSON",
        description: "Convert CSV data to JSON array of objects",
        example: "Example:",
        exampleInput: "Input: name,age,city\\nJohn,30,NYC",
        exampleOutput: "Output: [{\"name\":\"John\",\"age\":\"30\",\"city\":\"NYC\"}]",
        delimiter: "Delimiter",
        delimiterComma: "Comma (,)",
        delimiterSemicolon: "Semicolon (;)",
        delimiterTab: "Tab (\\t)",
        delimiterPipe: "Pipe (|)",
        delimiterHint: "Character used to separate fields in CSV",
        inputKey: "Input Key (Optional)",
        inputKeyPlaceholder: "e.g., csv, data, content",
        inputKeyHint: "If input is a map, specify the key containing CSV data.",
        headersConfig: "Headers Configuration",
        hasHeader: "First row contains headers",
        customHeaders: "Custom Headers",
        addHeader: "Add Header",
        headerPlaceholder: "Header",
        noCustomHeaders: "No custom headers. Auto-generated names (col_0, col_1, ...) will be used.",
        processingOptions: "Processing Options",
        trimSpaces: "Trim leading/trailing spaces",
        skipEmptyRows: "Skip empty rows"
      },
      rssParser: {
        title: "RSS Parser",
        description: "Fetch and parse RSS/Atom feeds, extract structured data",
        url: "RSS Feed URL",
        urlPlaceholder: "https://example.com/feed.xml",
        urlHint: "URL of the RSS or Atom feed to parse",
        maxItems: "Max Items",
        maxItemsPlaceholder: "0 = all items",
        maxItemsHint: "Maximum number of feed items to return (0 = unlimited)",
        options: "Options",
        includeContent: "Include Full Content",
        includeContentHint: "Include full article content in addition to summary",
        supportedFormats: "Supported Formats",
        autoDetection: "Auto-Detection",
        autoDetectionHint: "The parser automatically detects and handles both RSS and Atom feeds.",
        useCases: "Use Cases",
        outputFields: "Output Fields"
      },
      htmlClean: {
        title: "HTML Clean",
        description: "Extract readable content from HTML, removing scripts, styles, and boilerplate",
        outputFormat: "Output Format",
        outputFormatBoth: "Both (text + HTML)",
        outputFormatText: "Plain Text Only",
        outputFormatHtml: "Minimal HTML Only",
        outputFormatHint: "Choose what content format to return",
        options: "Options",
        extractMetadata: "Extract Metadata",
        extractMetadataHint: "Include title, author, excerpt, site name in output",
        preserveLinks: "Preserve Links",
        preserveLinksHint: "Convert links to markdown format [text](url) in text output",
        maxLength: "Max Length",
        maxLengthPlaceholder: "0 = no limit",
        maxLengthHint: "Truncate output to this many characters (0 = unlimited)",
        inputKey: "Input Key",
        inputKeyPlaceholder: "body, html, content, response...",
        inputKeyHint: "Key to extract from input data. Leave empty to auto-detect.",
        smartDetection: "Smart Detection",
        whatGetsRemoved: "What Gets Removed (HTML only)",
        whatGetsKept: "What Gets Kept",
        outputFields: "Output Fields"
      },
      adapter: {
        base64ToBytes: {
          title: "Base64 to Bytes Converter",
          description: "Decodes a base64-encoded string into raw bytes.",
          noConfig: "No configuration required. Input is automatically converted."
        },
        bytesToBase64: {
          title: "Bytes to Base64 Converter",
          description: "Encodes raw bytes into a base64 string.",
          noConfig: "No configuration required. Input is automatically converted."
        },
        stringToJson: {
          title: "String to JSON Parser",
          description: "Parses a JSON-formatted string into a structured object.",
          noConfig: "No configuration required. Input is automatically parsed."
        },
        jsonToString: {
          title: "JSON to String Serializer",
          description: "Serializes a structured object into a JSON-formatted string.",
          noConfig: "No configuration required. Input is automatically serialized."
        },
        bytesToJson: {
          title: "Bytes to JSON Parser",
          description: "Decodes bytes (UTF-8) and parses the result as JSON.",
          noConfig: "No configuration required. Input is automatically decoded and parsed."
        },
        fileToBytes: {
          title: "File to Bytes Reader",
          description: "Reads a file from storage and outputs its content as raw bytes.",
          noConfig: "No configuration required. Accepts File object from storage nodes."
        },
        bytesToFile: {
          title: "Bytes to File Writer",
          description: "Writes raw bytes to a file in storage.",
          filename: "Filename",
          filenamePlaceholder: "output.bin",
          filenameHint: "The name of the file to be created in storage"
        }
      },
      required: "*",
      optional: "(optional)"
    },
    modal: {
      closeAriaLabel: "Close modal",
      confirm: "Confirm"
    }
  },
  ru: {
    common: {
      save: "Сохранить",
      run: "Запуск",
      running: "Выполнение...",
      undo: "Отменить",
      redo: "Вернуть",
      saved: "Сохранено",
      unsaved: "Не сохранено",
      saving: "Сохранение...",
      lastSaved: "Сохр.",
      delete: "Удалить",
      cancel: "Отмена",
      search: "Поиск...",
      loading: "Загрузка",
      error: "Ошибка",
      success: "Успех",
      unknown: "Неизвестно",
      edit: "Редактировать",
      back: "Назад",
      close: "Закрыть",
      retry: "Повторить",
      name: "Название",
      description: "Описание",
      status: "Статус",
      refresh: "Обновить",
      created: "Создано",
      actions: "Действия",
      create: "Создать",
      previous: "Назад",
      next: "Далее"
    },
    sidebar: {
      dashboard: "Дашборд",
      workflows: "Процессы",
      executions: "История",
      triggers: "Триггеры",
      monitoring: "Мониторинг",
      resources: "Ресурсы",
      settings: "Настройки",
      signOut: "Выйти",
      title: "Workflow.ai"
    },
    dashboard: {
      title: "Обзор системы",
      subtitle: "Мониторинг здоровья и производительности автоматизаций.",
      totalWorkflows: "Всего процессов",
      executionsToday: "Запусков сегодня",
      successRate: "Успешность",
      avgDuration: "Ср. время",
      recentActivity: "Недавняя активность",
      viewAll: "Показать все",
      systemHealth: "Здоровье системы",
      quickActions: "Готовы создать?",
      createWorkflow: "Создать процесс",
      quickDesc: "Создайте новый процесс в визуальном редакторе.",
      table: {
        workflow: "Процесс",
        status: "Статус",
        duration: "Время",
        triggeredBy: "Источник",
        time: "Когда"
      }
    },
    builder: {
      components: "Компоненты",
      dragToAdd: "Перетащите",
      triggers: "ТРИГГЕРЫ",
      actions: "ДЕЙСТВИЯ",
      telegram: "TELEGRAM",
      logic: "ЛОГИКА",
      storage: "ХРАНИЛИЩЕ",
      adapters: "АДАПТЕРЫ",
      properties: "Свойства",
      general: "Основное",
      name: "Название",
      description: "Описание",
      deleteNode: "Удалить узел",
      nodeConfig: "Конфигурация",
      noConfigAvailable: "Нет доступных настроек для этого типа узла."
    },
    monitoring: {
      title: "Монитор выполнения",
      consoleLogs: "Логи консоли",
      io: "Входы / Выходы",
      clear: "Очистить",
      ready: "Готов к запуску. Нажмите 'Запуск'.",
      inputs: "ВХОДНЫЕ ДАННЫЕ",
      outputs: "ВЫХОДНЫЕ ДАННЫЕ",
      selectNode: "Выберите узел для просмотра данных."
    },
    settings: {
      title: "Настройки",
      profile: "Профиль",
      notifications: "Уведомления",
      security: "Безопасность",
      billing: "Оплата",
      appearance: "Внешний вид",
      profileInfo: "Информация профиля",
      profileDesc: "Обновите данные аккаунта и email.",
      firstName: "Имя",
      lastName: "Фамилия",
      email: "Email адрес",
      bio: "О себе",
      saveChanges: "Сохранить изменения"
    },
    nodes: {
      // Triggers
      delay: "Задержка / Планировщик",

      // Actions
      http: "HTTP Запрос",
      llm: "LLM / AI",
      transform: "Трансформация",
      functionCall: "Вызов функции",

      // Telegram
      telegram: "Telegram отправка",
      telegramDownload: "TG Загрузка",
      telegramParse: "TG Парсинг",
      telegramCallback: "TG Callback",

      // Logic
      conditional: "Условие",
      merge: "Объединение",

      // Storage
      fileStorage: "Файловое хранилище",

      // Adapters
      HTMLCleaner: "HTML клинер",
      base64ToBytes: "Base64 → Байты",
      bytesToBase64: "Байты → Base64",
      stringToJson: "Строка → JSON",
      jsonToString: "JSON → Строка",
      bytesToJson: "Байты → JSON",
      fileToBytes: "Файл → Байты",
      bytesToFile: "Байты → Файл",
      csvToJson: "CSV → JSON",

      // External integrations
      googleSheets: "Google Таблицы",
      googleDrive: "Google Диск",

      // Legacy keys (for backwards compatibility)
      scheduler: "Планировщик",
      telegramBot: "Telegram Бот",
      apiRequest: "HTTP Запрос",
      aiGenerator: "AI Генератор",
      condition: "Условие"
    },
    executions: {
      title: "История выполнений",
      subtitle: "Просмотр и управление выполнениями процессов",
      filters: "Фильтры",
      allWorkflows: "Все процессы",
      allStatuses: "Все статусы",
      dateRange: "Период",
      applyFilters: "Применить",
      clearFilters: "Сбросить",
      table: {
        id: "ID",
        workflow: "Процесс",
        status: "Статус",
        startedAt: "Запущен",
        duration: "Время",
        triggeredBy: "Источник",
        actions: "Действия"
      },
      status: {
        pending: "Ожидание",
        running: "Выполняется",
        completed: "Завершен",
        failed: "Ошибка",
        cancelled: "Отменен"
      },
      actions: {
        viewDetails: "Детали",
        retry: "Повтор",
        cancel: "Отмена"
      },
      details: {
        title: "Детали выполнения",
        overview: "Обзор",
        nodeExecutions: "Выполнение узлов",
        logs: "Логи",
        input: "Вход",
        output: "Выход",
        error: "Ошибка",
        close: "Закрыть"
      },
      noData: "Выполнений не найдено",
      loadMore: "Загрузить еще",
      pagination: {
        showing: "Показано",
        of: "из",
        results: "результатов"
      }
    },
    executionDetail: {
      title: "Детали выполнения",
      backToList: "К списку выполнений",
      refresh: "Обновить",
      copy: "Копировать",
      copied: "Скопировано!",
      noData: "Нет данных",
      fields: "полей",
      error: "Ошибка",
      input: "Входные данные",
      output: "Выходные данные",
      startedAt: "Запущен",
      completedAt: "Завершен",
      retryCount: "Попыток",
      totalNodes: "Всего узлов",
      nodeExecutions: "Выполнение узлов",
      nodeExecutionsDesc: "Нажмите на узел для просмотра входов и выходов",
      expandAll: "Развернуть все",
      collapseAll: "Свернуть все",
      noNodeExecutions: "Выполнения узлов не найдены",
      overview: "Обзор",
      metadata: "Метаданные",
      variables: "Переменные",
      executionError: "Ошибка выполнения",
      notFound: "Выполнение не найдено",
      fetchError: "Не удалось загрузить детали выполнения",
      retryStarted: "Повторный запуск начат",
      retryFailed: "Не удалось повторить выполнение"
    },
    auth: {
      signIn: "Войти",
      signUp: "Регистрация",
      signOut: "Выйти",
      signInDescription: "Введите свои данные для входа в аккаунт",
      signUpDescription: "Создайте новый аккаунт",
      signingIn: "Вход...",
      creatingAccount: "Создание аккаунта...",
      createAccount: "Создать аккаунт",
      email: "Email",
      password: "Пароль",
      confirmPassword: "Подтвердите пароль",
      username: "Имя пользователя",
      fullName: "Полное имя",
      noAccount: "Нет аккаунта?",
      alreadyHaveAccount: "Уже есть аккаунт?",
      passwordsDoNotMatch: "Пароли не совпадают",
      passwordTooShort: "Пароль должен быть не менее 8 символов",
      usernameTooShort: "Имя пользователя должно быть не менее 3 символов",
      usernameHint: "Только буквы, цифры, подчеркивания и дефисы",
      passwordHint: "Минимум 8 символов с заглавной, строчной буквой и цифрой"
    },
    nav: {
      settings: "Настройки",
      userManagement: "Управление пользователями",
      rentalKeys: "Арендные ключи"
    },
    admin: {
      userManagement: "Управление пользователями",
      userManagementDescription: "Управление пользователями и их ролями",
      addUser: "Добавить пользователя",
      user: "Пользователь",
      email: "Email",
      roles: "Роли",
      status: "Статус",
      actions: "Действия",
      active: "Активен",
      inactive: "Неактивен",
      activate: "Активировать",
      deactivate: "Деактивировать",
      edit: "Редактировать",
      loadError: "Не удалось загрузить пользователей",
      userDeleted: "Пользователь удалён",
      deleteError: "Не удалось удалить пользователя",
      userActivated: "Пользователь активирован",
      userDeactivated: "Пользователь деактивирован",
      updateError: "Не удалось обновить пользователя",
      pagination: {
        showing: "Показано",
        to: "до",
        of: "из",
        users: "пользователей",
        previous: "Назад",
        next: "Далее"
      },
      deleteModal: {
        title: "Удалить пользователя",
        message: "Вы уверены, что хотите удалить этого пользователя? Это действие нельзя отменить.",
        confirm: "Удалить"
      },
      // Rental Keys Admin
      rentalKeysManagement: "Управление арендными ключами",
      createKey: "Создать ключ",
      createRentalKey: "Создать арендный ключ",
      editRentalKey: "Редактировать арендный ключ",
      deleteRentalKey: "Удалить арендный ключ",
      deleteRentalKeyConfirm: "Вы уверены, что хотите удалить",
      rotateAPIKey: "Сменить API ключ",
      rotateKey: "Сменить ключ",
      rotatingKeyFor: "Смена ключа для",
      rotateKeyWarningTitle: "Внимание",
      rotateKeyWarning: "Смена API ключа немедленно сделает старый ключ недействительным. Все процессы, использующие этот арендный ключ, начнут использовать новый ключ при следующем выполнении.",
      newAPIKey: "Новый API ключ",
      newAPIKeyHint: "Этот ключ будет зашифрован и больше никогда не будет показан.",
      owner: "Владелец",
      allProviders: "Все провайдеры",
      allStatuses: "Все статусы",
      filterByOwner: "Фильтр по ID владельца...",
      noRentalKeys: "Арендные ключи не найдены",
      createFirstKey: "Создайте первый арендный ключ для начала работы",
      showingOf: "Показано",
      of: "из",
      usage: "Использование",
      dailyRequestLimit: "Дневной лимит запросов",
      monthlyTokenLimit: "Месячный лимит токенов",
      apiKey: "API ключ",
      apiKeyHint: "API ключ будет зашифрован и надёжно сохранён.",
      provisionerType: "Тип предоставления",
      selectOwner: "Выберите владельца",
      enterOwnerId: "Введите ID владельца",
      ownerUserId: "Владелец (ID пользователя)",
      ownerUser: "Владелец",
      selectUser: "Выберите пользователя...",
      searchUsers: "Поиск пользователей...",
      noUsersFound: "Пользователи не найдены",
      allOwners: "Все владельцы",
      provider: "Провайдер"
    },
    workflows: {
      title: "Процессы",
      subtitle: "Управление и организация ваших автоматизаций.",
      createNew: "Создать процесс",
      variablesGuide: "Справка по переменным",
      searchPlaceholder: "Поиск по названию или описанию...",
      allStatus: "Все статусы",
      draft: "Черновик",
      active: "Активен",
      inactive: "Неактивен",
      archived: "В архиве",
      showing: "Показано",
      workflow: "процесс",
      workflowsCount: "процессов",
      matching: "совпадений",
      tryAgain: "Повторить",
      noWorkflowsFound: "Процессы не найдены",
      noWorkflowsYet: "Пока нет процессов",
      adjustFilters: "Попробуйте изменить параметры поиска или фильтры.",
      getStarted: "Начните с создания вашего первого процесса.",
      createFirst: "Создать первый процесс",
      edit: "Редактировать",
      cloneTooltip: "Клонировать процесс",
      deleteTooltip: "Удалить процесс",
      previous: "Назад",
      next: "Далее",
      node: "узел",
      nodesCount: "узлов",
      created: "Создан",
      updated: "Обновлён",
      today: "Сегодня",
      yesterday: "Вчера",
      daysAgo: "дней назад",
      deleteModal: {
        title: "Удалить процесс",
        message: "Вы уверены, что хотите удалить этот процесс? Это действие нельзя отменить.",
        confirm: "Удалить"
      },
      errors: {
        cloneFailed: "Ошибка клонирования",
        cloneMessage: "Не удалось клонировать процесс. Попробуйте ещё раз.",
        deleteFailed: "Ошибка удаления",
        deleteMessage: "Не удалось удалить процесс. Попробуйте ещё раз."
      }
    },
    triggers: {
      title: "Триггеры",
      subtitle: "Управление триггерами и расписаниями запуска",
      createTrigger: "Создать триггер",
      filter: "Фильтр:",
      allTypes: "Все типы",
      manual: "Ручной",
      schedule: "По расписанию",
      webhook: "Webhook",
      event: "Событие",
      allStatus: "Все статусы",
      enabled: "Включён",
      disabled: "Выключен",
      ofTriggers: "из",
      triggersCount: "триггеров",
      noTriggersFound: "Триггеры не найдены",
      adjustFilters: "Попробуйте изменить фильтры",
      createFirst: "Создайте первый триггер для автоматизации запуска процессов",
      table: {
        name: "Название",
        type: "Тип",
        workflow: "Процесс",
        status: "Статус",
        nextRun: "Следующий запуск",
        lastTriggered: "Последний запуск",
        actions: "Действия"
      },
      executeNow: "Запустить сейчас",
      edit: "Редактировать",
      never: "Никогда",
      overdue: "Просрочен",
      inMinutes: "через {n} мин",
      inHours: "через {n} ч",
      inDays: "через {n} дн",
      createModal: {
        title: "Создать триггер",
        placeholder: "Форма создания триггера будет добавлена здесь."
      },
      editModal: {
        title: "Редактировать триггер",
        editing: "Редактирование триггера:"
      },
      deleteModal: {
        title: "Удалить триггер",
        message: "Вы уверены, что хотите удалить этот триггер? Это действие нельзя отменить.",
        confirm: "Удалить"
      }
    },
    resources: {
      pageTitle: "Ресурсы и биллинг",
      pageSubtitle: "Управление файловыми хранилищами и балансом аккаунта.",
      accountBalance: "Баланс аккаунта",
      fileStorageResources: "Файловые хранилища",
      createStorage: "Создать хранилище",
      noStorageYet: "Пока нет хранилищ",
      noStorageDescription: "Создайте первое файловое хранилище для начала работы.",
      storageUsage: "Использование хранилища",
      files: "файлов",
      file: "файл",
      used: "использовано",
      created: "Создано",
      viewFiles: "Просмотр файлов",
      createStorageTitle: "Создать файловое хранилище",
      storageName: "Название хранилища",
      storageNamePlaceholder: "напр., Продуктовое хранилище",
      description: "Описание",
      descriptionPlaceholder: "Необязательное описание...",
      create: "Создать",
      depositFundsTitle: "Пополнить баланс",
      deposit: "Пополнить",
      amount: "Сумма",
      amountPlaceholder: "0.00",
      amountHint: "Введите сумму для пополнения баланса аккаунта",
      filesTitle: "Файлы",
      chooseFile: "Выберите файл для загрузки",
      upload: "Загрузить",
      fileSize: "Размер файла",
      noFilesYet: "Пока нет загруженных файлов",
      showingFiles: "Показано",
      ofFiles: "из",
      totalFiles: "файлов",
      totalSize: "Всего",
      deleteFileTitle: "Удалить файл",
      deleteFileMessage: "Вы уверены, что хотите удалить этот файл? Это действие нельзя отменить.",
      deleteResourceTitle: "Удалить ресурс",
      deleteResourceMessage: "Вы уверены, что хотите удалить этот ресурс? Это действие нельзя отменить.",
      billingTransactions: "Биллинг и транзакции",
      depositFunds: "Пополнить баланс",
      transactionHistory: "История транзакций",
      showingTransactions: "Показано",
      ofTotal: "из",
      totalTransactions: "всего транзакций",
      noTransactionsYet: "Пока нет транзакций",
      type: "Тип",
      transactionDescription: "Описание",
      transactionAmount: "Сумма",
      status: "Статус",
      date: "Дата",
      transactionTypes: {
        deposit: "Пополнение",
        charge: "Списание",
        refund: "Возврат",
        storage: "Хранилище"
      },
      statuses: {
        active: "Активен",
        inactive: "Неактивен",
        completed: "Завершено",
        pending: "В ожидании",
        failed: "Ошибка"
      }
    },
    credentials: {
      title: "Учётные данные",
      create: "Создать",
      createTitle: "Создать учётные данные",
      editTitle: "Редактировать учётные данные",
      name: "Название",
      namePlaceholder: "напр., OpenAI API Key",
      description: "Описание",
      descriptionPlaceholder: "Необязательное описание...",
      provider: "Провайдер",
      type: "Тип",
      allTypes: "Все типы",
      filterByProvider: "Фильтр по провайдеру...",
      usageCount: "Использований",
      created: "Создано",
      lastUsed: "Последнее использование",
      expires: "Истекает",
      expired: "Истёк",
      viewSecrets: "Показать секреты",
      emptyTitle: "Нет учётных данных",
      emptyDescription: "Создайте первые учётные данные для безопасного хранения API ключей и секретов.",
      createFirst: "Создать первые учётные данные",
      deleteTitle: "Удалить учётные данные",
      deleteConfirmation: "Вы уверены, что хотите удалить \"{name}\"? Это действие нельзя отменить.",
      secretsWarningTitle: "Конфиденциальная информация",
      secretsWarningText: "Секреты будут показаны в открытом виде. Убедитесь, что никто не видит ваш экран.",
      expiredError: "Срок действия этих учётных данных истёк",
      username: "Имя пользователя",
      password: "Пароль",
      customFields: "Пользовательские поля",
      addField: "Добавить поле",
      apiKeyDescription: "Простой API ключ или токен для доступа к внешним сервисам",
      basicAuthDescription: "Комбинация логина и пароля для базовой аутентификации",
      oauth2Description: "OAuth2 учётные данные с client ID, secret и токенами",
      serviceAccountDescription: "JSON файл сервисного аккаунта (напр., Google Cloud)",
      customDescription: "Произвольные пары ключ-значение для любых типов учётных данных"
    },
    rentalKeys: {
      title: "Арендные ключи",
      allProviders: "Все провайдеры",
      noKeysTitle: "Нет арендных ключей",
      noKeysDescription: "У вас пока нет арендных ключей. Обратитесь к администратору для получения доступа к API ключам LLM.",
      noKeysForProvider: "Арендные ключи для этого провайдера не найдены.",
      provider: "Провайдер",
      status: "Статус",
      dailyLimit: "Дневной лимит",
      monthlyLimit: "Месячный лимит",
      requestsToday: "Запросов сегодня",
      tokensThisMonth: "Токенов в этом месяце",
      totalRequests: "Всего запросов",
      totalCost: "Общая стоимость",
      lastUsed: "Последнее использование",
      viewUsage: "История использования",
      usageHistory: "История использования",
      usageSummary: "Сводка использования",
      noUsageData: "Нет данных об использовании",
      noUsageRecords: "Записей об использовании не найдено",
      showingRecords: "Показано записей",
      model: "Модель",
      tokens: "Токены",
      cost: "Стоимость",
      time: "Время",
      unlimited: "Без ограничений",
      nearLimit: "Близко к лимиту",
      atLimit: "Лимит достигнут",
      dailyRequests: "Запросов за день",
      monthlyTokens: "Токенов за месяц",
      totalTokens: "Всего токенов",
      textTokens: "Текстовые токены",
      imageTokens: "Токены изображений",
      audioTokens: "Аудио токены",
      videoTokens: "Видео токены"
    },
    status: {
      active: "Активен",
      suspended: "Приостановлен",
      deleted: "Удалён"
    },
    templates: {
      title: "Шаблоны процессов",
      subtitle: "Начните с готового шаблона автоматизации с полной настройкой",
      searchPlaceholder: "Поиск шаблонов...",
      allTemplates: "Все шаблоны",
      basic: "Базовые",
      telegram: "Telegram",
      aiLlm: "AI и LLM",
      dataProcessing: "Обработка данных",
      use: "Использовать",
      nodesCount: "узлов",
      edgesCount: "связей",
      noResults: "Шаблоны не найдены по вашему запросу",
      loadModal: {
        title: "Загрузить шаблон",
        message: "Это заменит текущий процесс. Все несохранённые изменения будут потеряны. Продолжить?",
        confirm: "Загрузить шаблон"
      }
    },
    shortcuts: {
      title: "Горячие клавиши",
      saveWorkflow: "Сохранить процесс",
      runWorkflow: "Запустить процесс",
      undo: "Отменить",
      redo: "Вернуть",
      toggleFocusMode: "Режим фокуса",
      deleteNode: "Удалить выбранный узел",
      toggleShortcuts: "Показать горячие клавиши",
      proTip: "Подсказка: Правый клик на холсте откроет дополнительные опции."
    },
    header: {
      untitledWorkflow: "Без названия",
      clickToEdit: "Нажмите для редактирования названия",
      workflowVariables: "Переменные процесса",
      workflowResources: "Ресурсы процесса",
      templates: "Шаблоны",
      shortcuts: "Горячие клавиши",
      switchLanguage: "Сменить язык",
      focusMode: "Режим фокуса",
      toggleTheme: "Сменить тему"
    },
    canvas: {
      autoLayoutTopBottom: "Авто-раскладка (сверху вниз)",
      autoLayoutLeftRight: "Авто-раскладка (слева направо)"
    },
    edge: {
      title: "Настройка связи",
      connection: "Соединение",
      branch: "Ветка",
      trueBranch: "Ветка True",
      falseBranch: "Ветка False",
      branchDescription: "Выберите, какой ветке условного узла следует эта связь.",
      conditionExpression: "Условное выражение",
      optional: "(необязательно)",
      conditionPlaceholder: "output.status == \"success\"",
      conditionDescription: "Используйте синтаксис expr-lang. Связь будет активна только если условие истинно.",
      conditionExamples: "Примеры условий",
      saveChanges: "Сохранить изменения",
      deleteEdge: "Удалить связь",
      deleteModal: {
        title: "Удалить связь",
        message: "Вы уверены, что хотите удалить эту связь? Это действие нельзя отменить.",
        confirm: "Удалить"
      }
    },
    contextMenu: {
      duplicate: "Дублировать",
      copyId: "Копировать ID",
      resetView: "Сбросить вид"
    },
    variables: {
      title: "Переменные процесса",
      subtitle: "Определите переменные окружения для этого процесса",
      guide: "Справка по переменным",
      usageHint: "Используйте {{env.VARIABLE_NAME}} в настройках узлов для обращения к этим переменным.",
      noVariables: "Переменные ещё не определены",
      addFirst: "Добавьте первую переменную ниже",
      hideValue: "Скрыть значение",
      showValue: "Показать значение",
      copyTemplate: "Копировать шаблон",
      edit: "Редактировать",
      namePlaceholder: "ИМЯ_ПЕРЕМЕННОЙ",
      valuePlaceholder: "Значение...",
      add: "Добавить",
      namingRules: "Имена переменных должны быть ЗАГЛАВНЫМИ с подчёркиваниями (напр., API_KEY, BASE_URL)"
    },
    variablesGuide: {
      title: "Переменные и шаблоны",
      subtitle: "Справочное руководство по использованию переменных в процессах",
      templateSyntax: "Синтаксис шаблонов",
      templateDescription: "Используйте синтаксис {{variable.path}} для обращения к переменным в настройках узлов. Шаблоны разрешаются перед выполнением узла.",
      envTitle: "Переменные окружения (env)",
      envDescription: "Доступ к переменным уровня процесса и выполнения. Переменные выполнения переопределяют переменные процесса.",
      inputTitle: "Входные переменные (input)",
      inputDescription: "Доступ к данным от родительских узлов. Объект input содержит объединённые выходы всех подключённых родительских узлов.",
      nodeTitle: "Выходы узлов (прямая ссылка)",
      nodeDescription: "Ссылка на выход конкретного узла по его ID. Полезно когда нужны данные не от родительского узла.",
      transformModes: "Режимы преобразования",
      quickReference: "Быстрая справка"
    },
    quickAdd: {
      searchPlaceholder: "Поиск узлов...",
      noResults: "Узлы не найдены"
    },
    monitoringPanel: {
      selected: "Выбран",
      live: "Онлайн",
      offline: "Офлайн"
    },
    nodeConfig: {
      noDescription: "Описание отсутствует.",
      noConfig: "Нет доступных настроек для этого типа узла.",
      deleteConfirm: "Вы уверены, что хотите удалить этот узел? Это действие нельзя отменить.",
      http: {
        method: "HTTP Метод",
        url: "URL",
        urlPlaceholder: "https://api.example.com/endpoint",
        urlHint: "Поддерживает переменные шаблонов: {{env.API_KEY}}, {{node.previous.result}}",
        headers: "Заголовки",
        headerKeyPlaceholder: "Content-Type",
        headerValuePlaceholder: "application/json",
        removeHeader: "Удалить заголовок",
        addHeader: "+ Добавить заголовок",
        body: "Тело запроса",
        bodyPlaceholder: "{\"key\": \"value\"}",
        bodyHint: "Формат JSON. Поддерживает переменные шаблонов.",
        timeout: "Таймаут (секунды)",
        retryCount: "Количество повторов",
        followRedirects: "Следовать перенаправлениям"
      },
      llm: {
        provider: "Провайдер",
        model: "Модель",
        apiKey: "API Ключ",
        apiKeyPlaceholder: "{{env.openai_api_key}}",
        apiKeyHint: "Используйте шаблоны вида {{env.openai_api_key}} для ссылки на переменные процесса",
        systemPrompt: "Системный промпт (необязательно)",
        systemPromptPlaceholder: "Введите системные инструкции...",
        userPrompt: "Промпт пользователя",
        userPromptPlaceholder: "Введите промпт...",
        advancedSettings: "Расширенные настройки",
        temperature: "Temperature",
        temperatureHint: "(0.0 - 2.0, по умолчанию: 0.7)",
        maxTokens: "Макс. токенов",
        maxTokensHint: "(Максимальная длина ответа)",
        topP: "Top P",
        topPHint: "(0.0 - 1.0, nucleus sampling)",
        frequencyPenalty: "Frequency Penalty",
        frequencyPenaltyHint: "(-2.0 - 2.0)",
        presencePenalty: "Presence Penalty",
        presencePenaltyHint: "(-2.0 - 2.0)",
        stopSequences: "Стоп-последовательности (по одной на строку)",
        stopSequencesPlaceholder: "Введите стоп-последовательности, по одной на строку",
        responseFormat: "Формат ответа",
        responseFormatText: "Текст",
        responseFormatJson: "JSON",
        timeout: "Таймаут (секунды)",
        retryCount: "Количество повторов"
      },
      transform: {
        title: "Преобразование данных",
        description: "Преобразование входных данных различными методами: passthrough, шаблоны, выражения или jq-фильтры",
        transformationType: "Тип преобразования",
        passthrough: "Passthrough",
        passthroughDesc: "Передать входные данные без изменений следующему узлу",
        template: "Шаблон",
        templateDesc: "Использовать синтаксис шаблонов с переменными вида {{env.var}} или {{input.field}}",
        templateLabel: "Строка шаблона",
        templatePlaceholder: "Привет {{env.userName}}, ваш ввод: {{input.data}}",
        templateExamples: "Примеры шаблонов:",
        expression: "Выражение",
        expressionDesc: "Использовать expr-lang для сложных преобразований с доступом к переменной input",
        expressionLabel: "Выражение (expr-lang)",
        expressionPlaceholder: "input.field * 2",
        expressionExamples: "Примеры выражений:",
        jq: "JQ-фильтр",
        jqDesc: "Использовать синтаксис jq для преобразований и запросов JSON",
        jqLabel: "JQ-фильтр",
        jqPlaceholder: ".field | select(.value > 0)",
        jqExamples: "Примеры JQ:",
        timeout: "Таймаут (секунды)"
      },
      telegram: {
        credentials: "Учётные данные",
        botToken: "Токен бота",
        botTokenPlaceholder: "{{env.TELEGRAM_BOT_TOKEN}}",
        chatId: "ID чата",
        chatIdPlaceholder: "@channel_name или {{env.CHAT_ID}}",
        message: "Сообщение",
        messageType: "Тип сообщения",
        messageText: "Текст сообщения",
        messageTextPlaceholder: "Привет, мир! {{input.data}}",
        caption: "Подпись (необязательно)",
        captionPlaceholder: "Подпись медиа...",
        fileSettings: "Настройки файла",
        fileSource: "Источник файла",
        fileData: "URL файла",
        fileId: "ID файла",
        base64Data: "Base64 данные",
        fileDataPlaceholder: "https://example.com/image.jpg",
        fileName: "Имя файла (необязательно)",
        fileNamePlaceholder: "image.jpg",
        parseMode: "Режим парсинга",
        disableWebPagePreview: "Отключить предпросмотр веб-страниц",
        disableNotification: "Отключить уведомления",
        protectContent: "Защитить контент (запретить пересылку)",
        timeout: "Таймаут (секунды)"
      },
      telegramDownload: {
        credentials: "Учётные данные",
        botToken: "Токен бота",
        file: "Файл",
        fileId: "ID файла",
        fileIdPlaceholder: "{{input.message.document.file_id}}",
        fileIdHint: "ID файла из сообщения Telegram (фото, документ, аудио, видео и т.д.)",
        outputFormat: "Формат вывода",
        outputFormatBase64: "Base64 (скачать содержимое)",
        outputFormatUrl: "URL (только ссылка)",
        timeout: "Таймаут (секунды)"
      },
      telegramParse: {
        extractOptions: "Опции извлечения",
        extractFiles: "Извлекать файлы",
        extractFilesHint: "(документы, фото, видео, аудио)",
        extractCommands: "Извлекать команды",
        extractCommandsHint: "(напр., /start, /help)",
        extractEntities: "Извлекать сущности",
        extractEntitiesHint: "(упоминания, хештеги, URL)",
        infoText: "Выбранные опции управляют тем, какие данные извлекаются из обновлений Telegram и доступны в выходе узла."
      },
      telegramCallback: {
        credentials: "Учётные данные",
        botToken: "Токен бота",
        callbackQuery: "Callback запрос",
        callbackQueryId: "ID callback запроса",
        callbackQueryIdPlaceholder: "{{input.callback_query_id}}",
        textResponse: "Текстовый ответ (необязательно)",
        textResponsePlaceholder: "Запрос выполнен! {{input.result}}",
        showAlert: "Показать как всплывающее окно вместо уведомления",
        url: "URL (необязательно)",
        urlPlaceholder: "https://example.com",
        cacheTime: "Время кэширования (секунды)",
        timeout: "Таймаут (секунды)"
      },
      conditional: {
        conditionExpression: "Условное выражение",
        conditionPlaceholder: "{{input.value}} > 0",
        conditionHint: "Используйте синтаксис expr-lang для вычисления условий. Возвращает true/false.",
        examples: {
          title: "Примеры выражений",
          numeric: "{{input.value}} > 100 - числовое сравнение",
          string: "{{input.status}} == \"active\" - равенство строк",
          multiple: "{{input.count}} > 0 && {{input.enabled}} - множественные условия",
          arrayLength: "len({{input.items}}) > 5 - проверка длины массива"
        },
        notes: {
          title: "Важные замечания",
          trueBranch: "Ветка true: узлы, соединённые через связь с меткой \"true\" или первая связь по умолчанию",
          falseBranch: "Ветка false: узлы, соединённые через связь с меткой \"false\" или вторая связь",
          execution: "Если условие истинно, выполняется только ветка true",
          templates: "Шаблоны вида {{input.X}} разрешаются перед вычислением"
        },
        operators: {
          title: "Поддерживаемые операторы",
          comparison: "Сравнение",
          comparisonOps: "==, !=, >, <, >=, <=",
          logical: "Логические",
          logicalOps: "&&, ||, !",
          arithmetic: "Арифметические",
          arithmeticOps: "+, -, *, /, %",
          functions: "Функции",
          functionsOps: "len(), contains(), matches()"
        }
      },
      merge: {
        mergeStrategy: "Стратегия слияния",
        strategyFirst: "Первый (использовать первый доступный результат)",
        strategyLast: "Последний (использовать последний доступный результат)",
        strategyAll: "Все (объединить все результаты в массив)",
        strategyCustom: "Пользовательская (использовать выражение)",
        strategyHint: "Выберите способ объединения результатов от нескольких родительских узлов.",
        customExpression: "Пользовательское выражение слияния",
        customExpressionPlaceholder: "[{{input.parent1}}, {{input.parent2}}]",
        customExpressionHint: "Используйте expr-lang для определения пользовательской логики слияния."
      },
      delay: {
        title: "Узел задержки",
        description: "Приостановить выполнение процесса на указанное время",
        duration: "Длительность",
        durationPlaceholder: "Введите длительность",
        unitSeconds: "Секунды",
        unitMinutes: "Минуты",
        unitHours: "Часы",
        descriptionLabel: "Описание",
        descriptionOptional: "(необязательно)",
        descriptionPlaceholder: "Добавьте заметку о том, зачем нужна эта задержка...",
        preview: "Предпросмотр",
        previewWait: "Ожидание"
      },
      fileStorage: {
        action: "Действие",
        actionStore: "Сохранить файл",
        actionGet: "Получить файл",
        actionDelete: "Удалить файл",
        actionList: "Список файлов",
        actionMetadata: "Получить метаданные",
        storageId: "ID хранилища (необязательно)",
        storageIdPlaceholder: "default",
        storageIdHint: "Оставьте пустым для хранилища по умолчанию",
        fileSource: "Источник файла",
        sourceType: "Тип источника",
        sourceTypeUrl: "URL",
        sourceTypeBase64: "Base64 данные",
        fileUrl: "URL файла",
        fileUrlPlaceholder: "https://example.com/document.pdf или {{input.url}}",
        base64Data: "Base64 данные",
        base64Placeholder: "{{input.base64_data}}",
        fileName: "Имя файла",
        fileNamePlaceholder: "document.pdf или {{input.filename}}",
        mimeType: "MIME-тип (необязательно)",
        mimeTypePlaceholder: "Определяется автоматически, если пусто",
        storageOptions: "Опции хранения",
        accessScope: "Область доступа",
        accessScopeWorkflow: "Процесс",
        accessScopeEdge: "Связь (связанные узлы)",
        accessScopeResult: "Результат (хранилище вывода)",
        ttl: "TTL (секунды, 0 = без истечения)",
        ttlPlaceholder: "0",
        tags: "Теги (через запятую)",
        tagsPlaceholder: "документ, важное",
        fileId: "ID файла",
        fileIdPlaceholder: "{{input.file_id}}",
        filters: "Фильтры",
        allScopes: "Все области",
        tagsFilter: "Фильтр тегов (через запятую)",
        limit: "Лимит",
        limitPlaceholder: "100",
        offset: "Смещение",
        offsetPlaceholder: "0"
      },
      functionCall: {
        functionName: "Имя функции",
        functionNamePlaceholder: "my_function",
        arguments: "Аргументы (JSON)",
        argumentsPlaceholder: "{\"key\": \"{{input.value}}\"}",
        argumentsHint: "Введите аргументы функции как JSON объект. Можно использовать переменные шаблонов вида {{env.api_key}} или {{input.user_id}}",
        timeout: "Таймаут (секунды)"
      },
      googleSheets: {
        title: "Google Таблицы",
        description: "Чтение, запись и добавление данных в Google Таблицы с использованием сервисного аккаунта",
        operation: "Операция",
        operationRead: "Чтение",
        operationWrite: "Запись (перезапись)",
        operationAppend: "Добавление",
        operationHint: "Выберите, читать, писать (перезаписывать) или добавлять данные",
        spreadsheetId: "ID таблицы",
        spreadsheetIdPlaceholder: "1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms",
        spreadsheetIdHint: "ID из URL таблицы (между /d/ и /edit)",
        sheetName: "Имя листа",
        sheetNamePlaceholder: "Sheet1",
        sheetNameHint: "Необязательно. Имя вкладки листа (по умолчанию первый лист)",
        range: "Диапазон (нотация A1)",
        rangePlaceholder: "A1:D10",
        rangeHint: "Необязательно. Диапазон ячеек в нотации A1 (напр., A1:D10, B2:C5)",
        credentials: "Учётные данные сервисного аккаунта (JSON)",
        credentialsPlaceholder: "{\"type\":\"service_account\",\"project_id\":\"...\",\"private_key\":\"...\",\"client_email\":\"...\"}",
        credentialsHint: "Полный JSON учётных данных из консоли Google Cloud",
        valueInputOption: "Опция ввода значений",
        valueInputOptionUserEntered: "User Entered (парсить формулы, даты)",
        valueInputOptionRaw: "Raw (сохранять как есть)",
        valueInputOptionHint: "Как интерпретировать входные значения",
        majorDimension: "Основное измерение",
        majorDimensionRows: "Строки (по умолчанию)",
        majorDimensionColumns: "Столбцы",
        majorDimensionHint: "Как интерпретировать массивы данных",
        columnMapping: "Сопоставление столбцов",
        columnMappingPlaceholder: "title, description, link, categories, pubDate",
        columnMappingHint: "Необязательно. Список имён полей через запятую для извлечения из объектов.",
        inputDataFormat: "Формат входных данных"
      },
      googleDrive: {
        title: "Google Диск",
        description: "Управление файлами и папками в Google Диске с использованием сервисного аккаунта",
        operation: "Операция",
        operationCreateSpreadsheet: "Создать таблицу",
        operationCreateFolder: "Создать папку",
        operationListFiles: "Список файлов",
        operationDelete: "Удалить файл/папку",
        operationMove: "Переместить файл",
        operationCopy: "Копировать файл",
        operationHint: "Выберите операцию для выполнения в Google Диске",
        credentials: "Учётные данные сервисного аккаунта (JSON)",
        credentialsPlaceholder: "{\"type\":\"service_account\",\"project_id\":\"...\",\"private_key\":\"...\",\"client_email\":\"...\"}",
        credentialsHint: "Полный JSON учётных данных из консоли Google Cloud",
        fileName: "Имя файла",
        fileNameOptional: "(необязательно)",
        fileNamePlaceholder: "Таблица без названия",
        fileNameHint: "Имя нового файла",
        folderName: "Имя папки",
        folderNamePlaceholder: "Папка без названия",
        folderNameHint: "Имя новой папки",
        fileId: "ID файла",
        fileIdPlaceholder: "1BxiMVs0XRA5nFMdKvBdBZjgmUUqptlbs74OgvE2upms",
        fileIdHint: "ID файла Google Диска",
        parentFolderId: "ID родительской папки",
        parentFolderIdPlaceholder: "Оставьте пустым для корневой папки",
        parentFolderIdHint: "Папка, где будет создан файл/папка",
        destinationFolderId: "ID папки назначения",
        destinationFolderIdPlaceholder: "ID папки назначения",
        destinationFolderIdHint: "ID папки, куда будет перемещён/скопирован файл",
        maxResults: "Макс. результатов",
        maxResultsHint: "Максимальное количество файлов для возврата (по умолчанию: 100)",
        orderBy: "Сортировка",
        orderByModifiedDesc: "Время изменения (новые первые)",
        orderByModified: "Время изменения (старые первые)",
        orderByCreatedDesc: "Время создания (новые первые)",
        orderByCreated: "Время создания (старые первые)",
        orderByName: "Имя (А-Я)",
        orderByNameDesc: "Имя (Я-А)",
        orderByHint: "Порядок сортировки для списка файлов",
        outputVariables: "Выходные переменные"
      },
      csvToJson: {
        title: "CSV → JSON",
        description: "Преобразование CSV-данных в JSON-массив объектов",
        example: "Пример:",
        exampleInput: "Ввод: name,age,city\\nJohn,30,NYC",
        exampleOutput: "Вывод: [{\"name\":\"John\",\"age\":\"30\",\"city\":\"NYC\"}]",
        delimiter: "Разделитель",
        delimiterComma: "Запятая (,)",
        delimiterSemicolon: "Точка с запятой (;)",
        delimiterTab: "Табуляция (\\t)",
        delimiterPipe: "Вертикальная черта (|)",
        delimiterHint: "Символ, используемый для разделения полей в CSV",
        inputKey: "Ключ ввода (необязательно)",
        inputKeyPlaceholder: "напр., csv, data, content",
        inputKeyHint: "Если ввод — это объект, укажите ключ, содержащий CSV-данные.",
        headersConfig: "Настройка заголовков",
        hasHeader: "Первая строка содержит заголовки",
        customHeaders: "Пользовательские заголовки",
        addHeader: "Добавить заголовок",
        headerPlaceholder: "Заголовок",
        noCustomHeaders: "Нет пользовательских заголовков. Будут использованы автоматические имена (col_0, col_1, ...).",
        processingOptions: "Опции обработки",
        trimSpaces: "Обрезать начальные/конечные пробелы",
        skipEmptyRows: "Пропускать пустые строки"
      },
      rssParser: {
        title: "Парсер RSS",
        description: "Получение и парсинг RSS/Atom-лент, извлечение структурированных данных",
        url: "URL RSS-ленты",
        urlPlaceholder: "https://example.com/feed.xml",
        urlHint: "URL RSS- или Atom-ленты для парсинга",
        maxItems: "Макс. элементов",
        maxItemsPlaceholder: "0 = все элементы",
        maxItemsHint: "Максимальное количество элементов ленты (0 = без ограничений)",
        options: "Опции",
        includeContent: "Включить полное содержимое",
        includeContentHint: "Включить полное содержимое статьи в дополнение к резюме",
        supportedFormats: "Поддерживаемые форматы",
        autoDetection: "Автоопределение",
        autoDetectionHint: "Парсер автоматически определяет и обрабатывает RSS и Atom-ленты.",
        useCases: "Примеры использования",
        outputFields: "Выходные поля"
      },
      htmlClean: {
        title: "Очистка HTML",
        description: "Извлечение читаемого контента из HTML с удалением скриптов, стилей и вспомогательных элементов",
        outputFormat: "Формат вывода",
        outputFormatBoth: "Оба (текст + HTML)",
        outputFormatText: "Только простой текст",
        outputFormatHtml: "Только минимальный HTML",
        outputFormatHint: "Выберите формат возвращаемого контента",
        options: "Опции",
        extractMetadata: "Извлекать метаданные",
        extractMetadataHint: "Включить заголовок, автора, отрывок, название сайта в вывод",
        preserveLinks: "Сохранять ссылки",
        preserveLinksHint: "Преобразовать ссылки в markdown-формат [текст](url) в текстовом выводе",
        maxLength: "Макс. длина",
        maxLengthPlaceholder: "0 = без ограничений",
        maxLengthHint: "Обрезать вывод до этого количества символов (0 = без ограничений)",
        inputKey: "Ключ ввода",
        inputKeyPlaceholder: "body, html, content, response...",
        inputKeyHint: "Ключ для извлечения из входных данных. Оставьте пустым для автоопределения.",
        smartDetection: "Умное определение",
        whatGetsRemoved: "Что удаляется (только HTML)",
        whatGetsKept: "Что сохраняется",
        outputFields: "Выходные поля"
      },
      adapter: {
        base64ToBytes: {
          title: "Преобразователь Base64 в байты",
          description: "Декодирует base64-закодированную строку в необработанные байты.",
          noConfig: "Настройка не требуется. Ввод автоматически преобразуется."
        },
        bytesToBase64: {
          title: "Преобразователь байтов в Base64",
          description: "Кодирует необработанные байты в base64-строку.",
          noConfig: "Настройка не требуется. Ввод автоматически преобразуется."
        },
        stringToJson: {
          title: "Парсер строки в JSON",
          description: "Парсит JSON-форматированную строку в структурированный объект.",
          noConfig: "Настройка не требуется. Ввод автоматически парсится."
        },
        jsonToString: {
          title: "Сериализатор JSON в строку",
          description: "Сериализует структурированный объект в JSON-форматированную строку.",
          noConfig: "Настройка не требуется. Ввод автоматически сериализуется."
        },
        bytesToJson: {
          title: "Парсер байтов в JSON",
          description: "Декодирует байты (UTF-8) и парсит результат как JSON.",
          noConfig: "Настройка не требуется. Ввод автоматически декодируется и парсится."
        },
        fileToBytes: {
          title: "Читатель файлов в байты",
          description: "Читает файл из хранилища и выводит его содержимое в виде необработанных байтов.",
          noConfig: "Настройка не требуется. Принимает объект File из узлов хранилища."
        },
        bytesToFile: {
          title: "Записывающий байты в файл",
          description: "Записывает необработанные байты в файл в хранилище.",
          filename: "Имя файла",
          filenamePlaceholder: "output.bin",
          filenameHint: "Имя файла, который будет создан в хранилище"
        }
      },
      required: "*",
      optional: "(необязательно)"
    },
    modal: {
      closeAriaLabel: "Закрыть окно",
      confirm: "Подтвердить"
    }
  }
};

export const useTranslation = () => {
  const { language } = useUIStore();

  // Return the dictionary for the current language
  // Fallback to English if something goes wrong, though types prevent valid keys
  return dictionaries[language] || dictionaries.en;
};

// Helper function for translations with fallback support
// Usage: t('auth.signIn', 'Sign In') or t('auth.signIn')
export const useTranslations = () => {
  const { language } = useUIStore();
  const dict = dictionaries[language] || dictionaries.en;
  const fallbackDict = dictionaries.en;

  return (key: string, fallback?: string): string => {
    const keys = key.split('.');
    let value: unknown = dict;
    let fallbackValue: unknown = fallbackDict;

    for (const k of keys) {
      if (value && typeof value === 'object' && k in value) {
        value = (value as Record<string, unknown>)[k];
      } else {
        value = undefined;
      }
      if (fallbackValue && typeof fallbackValue === 'object' && k in fallbackValue) {
        fallbackValue = (fallbackValue as Record<string, unknown>)[k];
      } else {
        fallbackValue = undefined;
      }
    }

    if (typeof value === 'string') {
      return value;
    }
    if (typeof fallbackValue === 'string') {
      return fallbackValue;
    }
    return fallback ?? key;
  };
};